# åˆ·ç‰™æ¸¸æˆ Web MVP - é¡¹ç›®å®æ–½æ–‡æ¡£

> ç‰ˆæœ¬: 1.0
> æ›´æ–°æ—¥æœŸ: 2024-12-19
> é¡¹ç›®çŠ¶æ€: MVP å¼€å‘å®Œæˆ

---

## ç›®å½•

1. [é¡¹ç›®æ¦‚è¿°](#1-é¡¹ç›®æ¦‚è¿°)
2. [æŠ€æœ¯æ¶æ„](#2-æŠ€æœ¯æ¶æ„)
3. [é¡¹ç›®ç»“æ„è¯¦è§£](#3-é¡¹ç›®ç»“æ„è¯¦è§£)
4. [ç±»å‹ç³»ç»Ÿè®¾è®¡](#4-ç±»å‹ç³»ç»Ÿè®¾è®¡)
5. [é…ç½®ç®¡ç†ç³»ç»Ÿ](#5-é…ç½®ç®¡ç†ç³»ç»Ÿ)
6. [MediaPipe é›†æˆå±‚](#6-mediapipe-é›†æˆå±‚)
7. [æ£€æµ‹å™¨å®ç°è¯¦è§£](#7-æ£€æµ‹å™¨å®ç°è¯¦è§£)
8. [æ¸¸æˆçŠ¶æ€æœº](#8-æ¸¸æˆçŠ¶æ€æœº)
9. [æ¸²æŸ“ç³»ç»Ÿ](#9-æ¸²æŸ“ç³»ç»Ÿ)
10. [React Hooks å±‚](#10-react-hooks-å±‚)
11. [React ç»„ä»¶å±‚](#11-react-ç»„ä»¶å±‚)
12. [æ•°æ®æµä¸äº¤äº’](#12-æ•°æ®æµä¸äº¤äº’)
13. [å…³é”®ç®—æ³•ä¸å‚æ•°](#13-å…³é”®ç®—æ³•ä¸å‚æ•°)
14. [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#14-æ€§èƒ½ä¼˜åŒ–ç­–ç•¥)
15. [é—®é¢˜æ’æŸ¥æŒ‡å—](#15-é—®é¢˜æ’æŸ¥æŒ‡å—)
16. [iOS è¿ç§»æŒ‡å—](#16-ios-è¿ç§»æŒ‡å—)

---

## 1. é¡¹ç›®æ¦‚è¿°

### 1.1 äº§å“å®šä½

æœ¬é¡¹ç›®æ˜¯ä¸€ä¸ªç±»ä¼¼ **Pokemon Smile** çš„å„¿ç«¥åˆ·ç‰™æ¸¸æˆ Web MVPï¼Œé€šè¿‡å®æ—¶äººè„¸å’Œæ‰‹éƒ¨è¿½è¸ªæŠ€æœ¯ï¼Œè®©åˆ·ç‰™å˜æˆæœ‰è¶£çš„äº’åŠ¨æ¸¸æˆä½“éªŒã€‚

### 1.2 æ ¸å¿ƒåŠŸèƒ½

| åŠŸèƒ½æ¨¡å— | æè¿° | å®ç°çŠ¶æ€ |
|---------|------|---------|
| äººè„¸è¿½è¸ª | MediaPipe Face Landmarker 468ç‚¹è¿½è¸ª | âœ… å®Œæˆ |
| æ‰‹éƒ¨è¿½è¸ª | MediaPipe Hand Landmarker 21ç‚¹è¿½è¸ª | âœ… å®Œæˆ |
| éœ²ç‰™æ£€æµ‹ | åŸºäº Blendshapes jawOpen åˆ¤å®š | âœ… å®Œæˆ |
| æ¡æ‹³æ£€æµ‹ | åŸºäºæ‰‹æŒ‡å…³é”®ç‚¹å·æ›²åº¦åˆ¤å®š | âœ… å®Œæˆ |
| æ™ƒåŠ¨æ£€æµ‹ | åŸºäºæ‰‹è…•é€Ÿåº¦æ»‘çª—åˆ¤å®š | âœ… å®Œæˆ |
| åˆ·ç‰™æ‰‹åŠ¿ | ç»„åˆéœ²ç‰™+æ¡æ‹³+æ™ƒåŠ¨åˆ¤å®š | âœ… å®Œæˆ |
| å¤´å¥—è·Ÿéš | AR Face Filter æ•ˆæœ | âœ… å®Œæˆ |
| æ¸¸æˆç§¯åˆ† | çŠ¶æ€æœºé©±åŠ¨çš„ç§¯åˆ†ç³»ç»Ÿ | âœ… å®Œæˆ |

### 1.3 æŠ€æœ¯æ ˆ

```
å‰ç«¯æ¡†æ¶:     React 18 + TypeScript 5
æ„å»ºå·¥å…·:     Vite 6
ML æ¡†æ¶:      MediaPipe Tasks Vision (WASM)
æ ·å¼æ–¹æ¡ˆ:     CSS Modules
å¼€å‘æœåŠ¡å™¨:   HTTPS (vite-plugin-basic-ssl)
```

### 1.4 æµè§ˆå™¨å…¼å®¹æ€§

| æµè§ˆå™¨ | æœ€ä½ç‰ˆæœ¬ | æµ‹è¯•çŠ¶æ€ |
|-------|---------|---------|
| Chrome | 88+ | âœ… å·²æµ‹è¯• |
| Safari | 15+ | âœ… å·²æµ‹è¯• |
| Firefox | 90+ | âš ï¸ å¾…æµ‹è¯• |
| Edge | 88+ | âš ï¸ å¾…æµ‹è¯• |

---

## 2. æŠ€æœ¯æ¶æ„

### 2.1 åˆ†å±‚æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     React Components                         â”‚
â”‚  (GameScreen, AvatarSelector, GamePlayScreen, TestScreen)   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      React Hooks                             â”‚
â”‚     (useCamera, useMediaPipe, useGameStateMachine)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    Core Business Logic                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Detectors  â”‚ â”‚   Rendering â”‚ â”‚   Game State Machine â”‚   â”‚
â”‚  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚ â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚ â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚   â”‚
â”‚  â”‚ TeethGate   â”‚ â”‚ AvatarRenderâ”‚ â”‚ initâ†’readyâ†’playing  â”‚   â”‚
â”‚  â”‚ Fist        â”‚ â”‚ DebugRender â”‚ â”‚ â†’brushingâ†’success   â”‚   â”‚
â”‚  â”‚ Shake       â”‚ â”‚             â”‚ â”‚ â†’gameover           â”‚   â”‚
â”‚  â”‚ BrushGestureâ”‚ â”‚             â”‚ â”‚                     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   MediaPipe Integration                      â”‚
â”‚          (FaceTracker, HandTracker)                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                     Utilities                                â”‚
â”‚              (Smoothing, Geometry)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   Types & Config                             â”‚
â”‚      (game.types, mediapipe.types, detector.types)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 æ•°æ®æµæ¦‚è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Camera    â”‚â”€â”€â”€â”€â–¶â”‚   <video>    â”‚â”€â”€â”€â”€â–¶â”‚  requestAnimationâ”‚
â”‚   Stream     â”‚     â”‚   Element    â”‚     â”‚     Frame Loop   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                    â”‚
                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                          â”‚                MediaPipe Detection                 â”‚
                          â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
                          â”‚  â”‚   FaceTracker   â”‚    â”‚   HandTracker   â”‚       â”‚
                          â”‚  â”‚ (468 landmarks) â”‚    â”‚ (21 landmarks)  â”‚       â”‚
                          â”‚  â”‚ + blendshapes   â”‚    â”‚ + worldCoords   â”‚       â”‚
                          â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚                      â”‚
                                      â–¼                      â–¼
                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                          â”‚              DetectionResult                       â”‚
                          â”‚   { faceResult, handResult, timestamp }           â”‚
                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                   â”‚
                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                          â”‚              BrushGesture Detector              â”‚
                          â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
                          â”‚  â”‚TeethGateâ”‚  â”‚  Fist  â”‚  â”‚ Shake  â”‚            â”‚
                          â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”˜  â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜            â”‚
                          â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
                          â”‚                  â–¼                              â”‚
                          â”‚         BrushGestureResult                      â”‚
                          â”‚   { stage, isBrushing, confidence }             â”‚
                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                               â”‚
                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                          â”‚            GameStateMachine                     â”‚
                          â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
                          â”‚  â”‚ State: initâ†’readyâ†’playingâ†’brushingâ†’   â”‚    â”‚
                          â”‚  â”‚        successâ†’gameover               â”‚    â”‚
                          â”‚  â”‚ Stats: score, brushCount, accuracy    â”‚    â”‚
                          â”‚  â”‚ Events: brush_success, game_over      â”‚    â”‚
                          â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                               â”‚
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚                            â”‚                            â”‚
                  â–¼                            â–¼                            â–¼
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ Canvas Render â”‚          â”‚  UI Update    â”‚           â”‚ Event Emit    â”‚
         â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚          â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚           â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
         â”‚ Video + Avatarâ”‚          â”‚ Score Display â”‚           â”‚ brush_success â”‚
         â”‚ + Debug Info  â”‚          â”‚ Progress Bar  â”‚           â”‚ game_over     â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3. é¡¹ç›®ç»“æ„è¯¦è§£

### 3.1 å®Œæ•´ç›®å½•ç»“æ„

```
toothbrush_demo/
â”‚
â”œâ”€â”€ public/                          # é™æ€èµ„æº
â”‚   â”œâ”€â”€ models/                      # MediaPipe æ¨¡å‹æ–‡ä»¶
â”‚   â”‚   â”œâ”€â”€ face_landmarker.task     # äººè„¸æ¨¡å‹ (~3.6MB)
â”‚   â”‚   â”œâ”€â”€ hand_landmarker.task     # æ‰‹éƒ¨æ¨¡å‹ (~7.6MB)
â”‚   â”‚   â””â”€â”€ README.md                # æ¨¡å‹è¯´æ˜
â”‚   â””â”€â”€ img/                         # å¤´å¥—å›¾ç‰‡
â”‚       â”œâ”€â”€ cat.png                  # çŒ«å’ªå¤´å¥—
â”‚       â”œâ”€â”€ dog.png                  # å°ç‹—å¤´å¥—
â”‚       â””â”€â”€ rabbit.png               # å…”å­å¤´å¥—
â”‚
â”œâ”€â”€ src/
â”‚   â”‚
â”‚   â”œâ”€â”€ types/                       # TypeScript ç±»å‹å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ index.ts                 # ç»Ÿä¸€å¯¼å‡º
â”‚   â”‚   â”œâ”€â”€ game.types.ts            # æ¸¸æˆçŠ¶æ€ã€äº‹ä»¶ã€é…ç½®ç±»å‹
â”‚   â”‚   â”œâ”€â”€ mediapipe.types.ts       # MediaPipe æ£€æµ‹ç»“æœç±»å‹
â”‚   â”‚   â””â”€â”€ detector.types.ts        # æ£€æµ‹å™¨æ¥å£å®šä¹‰
â”‚   â”‚
â”‚   â”œâ”€â”€ config/                      # é…ç½®ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ index.ts                 # ç»Ÿä¸€å¯¼å‡º
â”‚   â”‚   â”œâ”€â”€ default.config.ts        # é»˜è®¤é˜ˆå€¼å‚æ•°
â”‚   â”‚   â”œâ”€â”€ mediapipe.config.ts      # MediaPipe æ¨¡å‹è·¯å¾„
â”‚   â”‚   â””â”€â”€ avatar.config.ts         # å¤´å¥—é…ç½®åˆ—è¡¨
â”‚   â”‚
â”‚   â”œâ”€â”€ core/                        # æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ï¼ˆå¹³å°æ— å…³ï¼‰
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ detectors/               # æ£€æµ‹å™¨æ¨¡å—
â”‚   â”‚   â”‚   â”œâ”€â”€ TeethGate.ts         # éœ²ç‰™æ£€æµ‹å™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ Fist.ts              # æ¡æ‹³æ£€æµ‹å™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ Shake.ts             # æ™ƒåŠ¨æ£€æµ‹å™¨
â”‚   â”‚   â”‚   â””â”€â”€ BrushGesture.ts      # åˆ·ç‰™æ‰‹åŠ¿ç»„åˆæ£€æµ‹å™¨
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ game/                    # æ¸¸æˆé€»è¾‘
â”‚   â”‚   â”‚   â””â”€â”€ GameStateMachine.ts  # æ¸¸æˆçŠ¶æ€æœº
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ rendering/               # æ¸²æŸ“æ¨¡å—
â”‚   â”‚   â”‚   â”œâ”€â”€ AvatarRenderer.ts    # å¤´å¥—æ¸²æŸ“å™¨
â”‚   â”‚   â”‚   â””â”€â”€ DebugRenderer.ts     # è°ƒè¯•ä¿¡æ¯æ¸²æŸ“å™¨
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ utils/                   # å·¥å…·å‡½æ•°
â”‚   â”‚       â”œâ”€â”€ smoothing.ts         # EMA å¹³æ»‘ç®—æ³•
â”‚   â”‚       â””â”€â”€ geometry.ts          # å‡ ä½•è®¡ç®—å·¥å…·
â”‚   â”‚
â”‚   â”œâ”€â”€ mediapipe/                   # MediaPipe é›†æˆå±‚
â”‚   â”‚   â”œâ”€â”€ FaceTracker.ts           # Face Landmarker å°è£…
â”‚   â”‚   â””â”€â”€ HandTracker.ts           # Hand Landmarker å°è£…
â”‚   â”‚
â”‚   â”œâ”€â”€ hooks/                       # React Hooks
â”‚   â”‚   â”œâ”€â”€ useCamera.ts             # æ‘„åƒå¤´ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ useMediaPipe.ts          # MediaPipe æ¨ç†å¾ªç¯
â”‚   â”‚   â””â”€â”€ useGameStateMachine.ts   # æ¸¸æˆçŠ¶æ€æœºå°è£…
â”‚   â”‚
â”‚   â”œâ”€â”€ components/                  # React ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ GameScreen.tsx           # æ¸¸æˆä¸»å®¹å™¨
â”‚   â”‚   â”œâ”€â”€ AvatarSelector.tsx       # å¤´å¥—é€‰æ‹©ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ GamePlayScreen.tsx       # æ¸¸æˆç©æ³•ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ TestScreen.tsx           # æµ‹è¯•è°ƒè¯•ç»„ä»¶
â”‚   â”‚   â””â”€â”€ DiagnosticsScreen.tsx    # è¯Šæ–­ç»„ä»¶
â”‚   â”‚
â”‚   â”œâ”€â”€ styles/                      # æ ·å¼æ–‡ä»¶
â”‚   â”‚   â””â”€â”€ global.css               # å…¨å±€æ ·å¼
â”‚   â”‚
â”‚   â”œâ”€â”€ App.tsx                      # åº”ç”¨æ ¹ç»„ä»¶
â”‚   â”œâ”€â”€ main.tsx                     # å…¥å£æ–‡ä»¶
â”‚   â””â”€â”€ vite-env.d.ts                # Vite ç¯å¢ƒç±»å‹
â”‚
â”œâ”€â”€ index.html                       # HTML å…¥å£
â”œâ”€â”€ vite.config.ts                   # Vite æ„å»ºé…ç½®
â”œâ”€â”€ tsconfig.json                    # TypeScript ä¸»é…ç½®
â”œâ”€â”€ tsconfig.app.json                # TypeScript åº”ç”¨é…ç½®
â”œâ”€â”€ tsconfig.node.json               # TypeScript æ„å»ºå·¥å…·é…ç½®
â”œâ”€â”€ package.json                     # é¡¹ç›®ä¾èµ–å’Œè„šæœ¬
â”‚
â”œâ”€â”€ CLAUDE.md                        # Claude Code å·¥ä½œæŒ‡å—
â”œâ”€â”€ è®¾è®¡æ–‡æ¡£.md                       # åŸå§‹è®¾è®¡æ–‡æ¡£
â”œâ”€â”€ è®¾è®¡æ–‡æ¡£2.0.md                    # è®¾è®¡æ–‡æ¡£å‰¯æœ¬
â””â”€â”€ é¡¹ç›®å®æ–½æ–‡æ¡£.md                   # æœ¬æ–‡æ¡£
```

### 3.2 æ ¸å¿ƒæ–‡ä»¶èŒè´£è¡¨

| æ–‡ä»¶è·¯å¾„ | èŒè´£æè¿° | ä»£ç è¡Œæ•° |
|---------|---------|---------|
| `src/types/game.types.ts` | æ¸¸æˆçŠ¶æ€æšä¸¾ã€äº‹ä»¶ç±»å‹ã€é…ç½®æ¥å£ | ~120 |
| `src/types/mediapipe.types.ts` | MediaPipe æ£€æµ‹ç»“æœç±»å‹å®šä¹‰ | ~80 |
| `src/types/detector.types.ts` | æ£€æµ‹å™¨æ¥å£å’Œç»“æœç±»å‹ | ~60 |
| `src/config/default.config.ts` | é»˜è®¤é˜ˆå€¼å‚æ•°ã€URLè¦†ç›–é€»è¾‘ | ~100 |
| `src/config/avatar.config.ts` | å¤´å¥—é…ç½®ï¼ˆ3ä¸ªé¢„è®¾ï¼‰ | ~40 |
| `src/mediapipe/FaceTracker.ts` | Face Landmarker å°è£… | ~180 |
| `src/mediapipe/HandTracker.ts` | Hand Landmarker å°è£… | ~160 |
| `src/core/detectors/TeethGate.ts` | éœ²ç‰™æ£€æµ‹å®ç° | ~100 |
| `src/core/detectors/Fist.ts` | æ¡æ‹³æ£€æµ‹å®ç° | ~130 |
| `src/core/detectors/Shake.ts` | æ™ƒåŠ¨æ£€æµ‹å®ç° | ~160 |
| `src/core/detectors/BrushGesture.ts` | åˆ·ç‰™æ‰‹åŠ¿ç»„åˆæ£€æµ‹ | ~280 |
| `src/core/game/GameStateMachine.ts` | æ¸¸æˆçŠ¶æ€æœº | ~350 |
| `src/core/rendering/AvatarRenderer.ts` | å¤´å¥—æ¸²æŸ“ | ~140 |
| `src/hooks/useCamera.ts` | æ‘„åƒå¤´ç®¡ç† Hook | ~120 |
| `src/hooks/useMediaPipe.ts` | MediaPipe åˆå§‹åŒ– Hook | ~140 |
| `src/components/GamePlayScreen.tsx` | æ¸¸æˆä¸»ç•Œé¢ç»„ä»¶ | ~400 |

---

## 4. ç±»å‹ç³»ç»Ÿè®¾è®¡

### 4.1 æ¸¸æˆç±»å‹ (`src/types/game.types.ts`)

#### 4.1.1 æ¸¸æˆçŠ¶æ€æšä¸¾

```typescript
// æ¸¸æˆçŠ¶æ€ - ç®€åŒ–ç‰ˆï¼ˆå®é™…ä½¿ç”¨ï¼‰
export type GameState =
  | 'init'      // åˆå§‹åŒ–
  | 'ready'     // ç­‰å¾…éœ²ç‰™
  | 'playing'   // éœ²ç‰™ç¡®è®¤ï¼Œç­‰å¾…åˆ·ç‰™åŠ¨ä½œ
  | 'brushing'  // æ­£åœ¨åˆ·ç‰™
  | 'success'   // åˆ·ç‰™æˆåŠŸï¼ˆæ˜¾ç¤º500msï¼‰
  | 'gameover'; // æ¸¸æˆç»“æŸ

// å®Œæ•´çŠ¶æ€æšä¸¾ï¼ˆè®¾è®¡æ–‡æ¡£å®šä¹‰ï¼Œå¯æ‰©å±•ï¼‰
export enum GameState {
  S0_SELECT_AVATAR = 'S0_SELECT_AVATAR',
  S1_CAMERA_INIT = 'S1_CAMERA_INIT',
  S2_FACE_TRACKING = 'S2_FACE_TRACKING',
  S3_PROMPT_TEETH = 'S3_PROMPT_TEETH',
  S4_TEETH_CONFIRMED = 'S4_TEETH_CONFIRMED',
  S5_PROMPT_BRUSH_GESTURE = 'S5_PROMPT_BRUSH_GESTURE',
  S6_BRUSH_GESTURE_CONFIRMED = 'S6_BRUSH_GESTURE_CONFIRMED',
  S7_COMPLETED = 'S7_COMPLETED'
}
```

#### 4.1.2 æ¸¸æˆäº‹ä»¶æšä¸¾

```typescript
export enum GameEvent {
  AVATAR_SELECTED = 'AVATAR_SELECTED',
  CAMERA_READY = 'CAMERA_READY',
  FACE_DETECTED = 'FACE_DETECTED',
  FACE_LOST = 'FACE_LOST',
  TEETH_GATE_PASS = 'TEETH_GATE_PASS',
  FIST_DETECTED = 'FIST_DETECTED',
  SHAKE_PASS = 'SHAKE_PASS',
  GAME_COMPLETE = 'GAME_COMPLETE'
}
```

#### 4.1.3 å¤´å¥—é…ç½®æ¥å£

```typescript
export interface AvatarConfig {
  id: string;                        // å”¯ä¸€æ ‡è¯†
  name: string;                      // æ˜¾ç¤ºåç§°ï¼ˆå«emojiï¼‰
  imgUrl: string;                    // å›¾ç‰‡è·¯å¾„
  anchorOffset?: { x: number; y: number };   // é”šç‚¹åç§»ï¼ˆå½’ä¸€åŒ–ï¼‰
  faceHoleOffset?: { x: number; y: number }; // è„¸æ´åç§»ï¼ˆå½’ä¸€åŒ–ï¼‰
  scale?: number;                    // ç¼©æ”¾ç³»æ•°
}
```

#### 4.1.4 æ¸¸æˆé…ç½®æ¥å£

```typescript
export interface GameConfig {
  // éœ²ç‰™æ£€æµ‹
  teethGate: {
    openThreshold: number;           // å¼ å˜´é˜ˆå€¼ (0-1)
    stableMs: number;                // ç¨³å®šæ—¶é•¿ (ms)
    blendshapeKeys: string[];        // Blendshape é”®å
  };

  // æ¡æ‹³æ£€æµ‹
  fist: {
    curledFingersMin: number;        // æœ€å°‘å·æ›²æ‰‹æŒ‡
    distanceThreshold: number;       // å·æ›²åˆ¤å®šè·ç¦»
  };

  // æ™ƒåŠ¨æ£€æµ‹
  shake: {
    speedThreshold: number;          // é€Ÿåº¦é˜ˆå€¼ï¼ˆå½’ä¸€åŒ–ï¼‰
    windowMs: number;                // æ»‘çª—æ—¶é•¿ (ms)
    highSpeedRatio: number;          // é«˜é€Ÿå¸§å æ¯”
    directionChangesMin: number;     // æœ€å°‘æ–¹å‘å˜åŒ–
  };

  // æ¸²æŸ“è®¾ç½®
  rendering: {
    targetFps: number;               // ç›®æ ‡å¸§ç‡
    detectionFps: number;            // æ¨ç†å¸§ç‡
    videoResolution: { width: number; height: number };
    smoothingAlpha: number;          // EMA å¹³æ»‘ç³»æ•°
  };

  // è°ƒè¯•è®¾ç½®
  debug: {
    enabled: boolean;
  };
}
```

### 4.2 MediaPipe ç±»å‹ (`src/types/mediapipe.types.ts`)

#### 4.2.1 å…³é”®ç‚¹ç±»å‹

```typescript
// å½’ä¸€åŒ–åæ ‡ï¼ˆ0-1ï¼‰
export interface NormalizedLandmark {
  x: number;  // 0-1ï¼Œå·¦åˆ°å³
  y: number;  // 0-1ï¼Œä¸Šåˆ°ä¸‹
  z: number;  // æ·±åº¦ï¼ˆç›¸å¯¹å€¼ï¼‰
}

// ä¸–ç•Œåæ ‡ï¼ˆç±³ï¼‰
export interface WorldLandmark {
  x: number;  // ç±³
  y: number;  // ç±³
  z: number;  // ç±³
}
```

#### 4.2.2 äººè„¸æ£€æµ‹ç»“æœ

```typescript
export interface FaceTrackingResult {
  landmarks: NormalizedLandmark[] | null;  // 468ä¸ªå…³é”®ç‚¹
  blendshapes: Map<string, number>;        // è¡¨æƒ…ç³»æ•°
  faceCenter: Point;                       // å¹³æ»‘åçš„äººè„¸ä¸­å¿ƒ
  faceScale: number;                       // å¹³æ»‘åçš„äººè„¸å°ºåº¦
  faceRotation: number;                    // å¹³æ»‘åçš„æ—‹è½¬è§’åº¦
  timestamp: number;
}
```

#### 4.2.3 æ‰‹éƒ¨æ£€æµ‹ç»“æœ

```typescript
export interface HandTrackingResult {
  landmarks: NormalizedLandmark[] | null;   // 21ä¸ªå…³é”®ç‚¹
  worldLandmarks: WorldLandmark[] | null;   // 3Dä¸–ç•Œåæ ‡
  handedness: 'Left' | 'Right' | null;      // å·¦å³æ‰‹
  timestamp: number;
}
```

### 4.3 æ£€æµ‹å™¨ç±»å‹ (`src/types/detector.types.ts`)

#### 4.3.1 æ£€æµ‹ç»“æœæ¥å£

```typescript
// éœ²ç‰™æ£€æµ‹ç»“æœ
export interface TeethGateResult {
  isOpen: boolean;              // æ˜¯å¦å¼ å˜´
  jawOpenScore: number;         // jawOpen åˆ†æ•° (0-1)
  mouthOpenScore: number;       // mouthOpen åˆ†æ•° (0-1)
  confidence: number;           // ç½®ä¿¡åº¦ (0-1)
}

// æ¡æ‹³æ£€æµ‹ç»“æœ
export interface FistResult {
  isFist: boolean;              // æ˜¯å¦æ¡æ‹³
  curledFingersCount: number;   // å·æ›²æ‰‹æŒ‡æ•° (0-5)
  handSpread: number;           // æ‰‹æŒ‡å¼ å¼€åº¦ (0-1)
  confidence: number;           // ç½®ä¿¡åº¦ (0-1)
}

// æ™ƒåŠ¨æ£€æµ‹ç»“æœ
export interface ShakeResult {
  isShaking: boolean;           // æ˜¯å¦åœ¨æ™ƒåŠ¨
  currentSpeed: number;         // å½“å‰é€Ÿåº¦ï¼ˆå½’ä¸€åŒ–ï¼‰
  avgSpeed: number;             // å¹³å‡é€Ÿåº¦
  highSpeedRatio: number;       // é«˜é€Ÿå¸§æ¯”ä¾‹
  confidence: number;           // ç½®ä¿¡åº¦ (0-1)
}

// åˆ·ç‰™æ‰‹åŠ¿æ£€æµ‹ç»“æœ
export interface BrushGestureResult {
  isBrushing: boolean;          // æ˜¯å¦æ­£åœ¨åˆ·ç‰™
  teethGate: TeethGateResult;   // éœ²ç‰™å­ç»“æœ
  fist: FistResult;             // æ¡æ‹³å­ç»“æœ
  shake: ShakeResult;           // æ™ƒåŠ¨å­ç»“æœ
  brushingDirection: 'vertical' | 'horizontal' | 'none';
  confidence: number;           // ç»¼åˆç½®ä¿¡åº¦
  stage: 'waiting' | 'teeth_open' | 'fist_ready' | 'brushing' | 'complete';
}
```

---

## 5. é…ç½®ç®¡ç†ç³»ç»Ÿ

### 5.1 é»˜è®¤é…ç½® (`src/config/default.config.ts`)

```typescript
export const defaultConfig: GameConfig = {
  teethGate: {
    openThreshold: 0.5,
    stableMs: 400,
    blendshapeKeys: ['jawOpen', 'mouthOpen']
  },
  fist: {
    curledFingersMin: 4,
    distanceThreshold: 0.15
  },
  shake: {
    speedThreshold: 0.05,
    windowMs: 800,
    highSpeedRatio: 0.35,
    directionChangesMin: 3
  },
  rendering: {
    targetFps: 30,
    detectionFps: 20,
    videoResolution: { width: 640, height: 480 },
    smoothingAlpha: 0.3
  },
  debug: {
    enabled: false
  }
};
```

### 5.2 URL å‚æ•°è¦†ç›–

æ”¯æŒé€šè¿‡ URL å‚æ•°åŠ¨æ€è¦†ç›–é…ç½®ï¼š

```
https://localhost:5173/?debug.enabled=true&teethGate.openThreshold=0.4
```

**å®ç°é€»è¾‘**:

```typescript
function applyUrlOverrides(config: GameConfig): GameConfig {
  const params = new URLSearchParams(window.location.search);
  const clonedConfig = structuredClone(config);

  params.forEach((value, key) => {
    const keys = key.split('.');
    let target: any = clonedConfig;

    for (let i = 0; i < keys.length - 1; i++) {
      target = target[keys[i]];
    }

    const finalKey = keys[keys.length - 1];
    const numValue = parseFloat(value);

    if (!isNaN(numValue)) {
      target[finalKey] = numValue;
    } else if (value === 'true' || value === 'false') {
      target[finalKey] = value === 'true';
    } else {
      target[finalKey] = value;
    }
  });

  return clonedConfig;
}

export const gameConfig = applyUrlOverrides(defaultConfig);
```

### 5.3 MediaPipe é…ç½® (`src/config/mediapipe.config.ts`)

```typescript
export const mediaPipeConfig = {
  // WASM è¿è¡Œæ—¶è·¯å¾„ï¼ˆCDNï¼‰
  wasmPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.18/wasm',

  // æ¨¡å‹æ–‡ä»¶è·¯å¾„ï¼ˆæœ¬åœ°ï¼‰
  faceModelPath: '/models/face_landmarker.task',
  handModelPath: '/models/hand_landmarker.task',

  // Face Landmarker é€‰é¡¹
  faceOptions: {
    numFaces: 1,
    minFaceDetectionConfidence: 0.5,
    minFacePresenceConfidence: 0.5,
    minTrackingConfidence: 0.5,
    outputFaceBlendshapes: true,
    outputFacialTransformationMatrixes: false
  },

  // Hand Landmarker é€‰é¡¹
  handOptions: {
    numHands: 1,
    minHandDetectionConfidence: 0.5,
    minHandPresenceConfidence: 0.5,
    minTrackingConfidence: 0.5
  }
};
```

### 5.4 å¤´å¥—é…ç½® (`src/config/avatar.config.ts`)

```typescript
export const avatarConfigs: AvatarConfig[] = [
  {
    id: 'cat',
    name: 'ğŸ± çŒ«å’ª',
    imgUrl: '/img/cat.png',
    faceHoleOffset: { x: 0, y: 0.25 },   // è„¸æ´åœ¨å›¾ç‰‡ä¸‹æ–¹ 25%
    anchorOffset: { x: 0, y: -0.15 },    // æ•´ä½“å‘ä¸Šç§»åŠ¨ 15%
    scale: 1.0
  },
  {
    id: 'dog',
    name: 'ğŸ¶ å°ç‹—',
    imgUrl: '/img/dog.png',
    faceHoleOffset: { x: 0, y: 0.25 },
    anchorOffset: { x: 0, y: -0.15 },
    scale: 1.0
  },
  {
    id: 'rabbit',
    name: 'ğŸ° å…”å­',
    imgUrl: '/img/rabbit.png',
    faceHoleOffset: { x: 0, y: 0.25 },
    anchorOffset: { x: 0, y: -0.15 },
    scale: 1.0
  }
];

export const defaultAvatar = avatarConfigs[0];
```

---

## 6. MediaPipe é›†æˆå±‚

### 6.1 FaceTracker (`src/mediapipe/FaceTracker.ts`)

#### 6.1.1 ç±»ç»“æ„

```typescript
export class FaceTracker {
  private faceLandmarker: FaceLandmarker | null = null;
  private lastResult: FaceTrackingResult | null = null;
  private smoothingAlpha: number = 0.3;
  private isInitialized = false;

  // å¹³æ»‘çŠ¶æ€
  private smoothedCenter: Point = { x: 0, y: 0 };
  private smoothedScale: number = 1;
  private smoothedRotation: number = 0;
}
```

#### 6.1.2 åˆå§‹åŒ–æµç¨‹

```typescript
async initialize(
  modelPath: string,
  wasmPath?: string,
  smoothingAlpha?: number
): Promise<void> {
  // 1. åŠ è½½ WASM è¿è¡Œæ—¶
  const vision = await FilesetResolver.forVisionTasks(wasmPath);

  // 2. åˆ›å»º FaceLandmarker å®ä¾‹
  this.faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
    baseOptions: {
      modelAssetPath: modelPath,
      delegate: 'GPU'  // ä¼˜å…ˆä½¿ç”¨ GPU
    },
    runningMode: 'VIDEO',
    numFaces: 1,
    outputFaceBlendshapes: true
  });

  this.isInitialized = true;
}
```

#### 6.1.3 æ£€æµ‹é€»è¾‘

```typescript
detectForVideo(
  video: HTMLVideoElement,
  timestamp: number
): FaceTrackingResult {
  if (!this.faceLandmarker) {
    return this.getEmptyResult(timestamp);
  }

  // æ‰§è¡Œæ£€æµ‹
  const results = this.faceLandmarker.detectForVideo(video, timestamp);

  if (!results.faceLandmarks || results.faceLandmarks.length === 0) {
    return this.getEmptyResult(timestamp);
  }

  const landmarks = results.faceLandmarks[0];

  // æå– Blendshapes
  const blendshapes = new Map<string, number>();
  if (results.faceBlendshapes?.[0]) {
    results.faceBlendshapes[0].categories.forEach(cat => {
      blendshapes.set(cat.categoryName, cat.score);
    });
  }

  // è®¡ç®—äººè„¸å˜æ¢å‚æ•°
  const leftEye = landmarks[33];   // å·¦çœ¼å¤–è§’
  const rightEye = landmarks[263]; // å³çœ¼å¤–è§’

  // äººè„¸ä¸­å¿ƒ = ä¸¤çœ¼ä¸­ç‚¹
  const rawCenter = {
    x: (leftEye.x + rightEye.x) / 2,
    y: (leftEye.y + rightEye.y) / 2
  };

  // äººè„¸å°ºåº¦ = çœ¼è·ï¼ˆå½’ä¸€åŒ–ï¼‰
  const eyeDistance = distance(leftEye, rightEye);
  const rawScale = eyeDistance * 3;  // æ”¾å¤§ç³»æ•°

  // äººè„¸æ—‹è½¬ = çœ¼é—´è¿çº¿è§’åº¦
  const rawRotation = Math.atan2(
    rightEye.y - leftEye.y,
    rightEye.x - leftEye.x
  );

  // EMA å¹³æ»‘
  this.smoothedCenter = smoothPoint(
    this.smoothedCenter, rawCenter, this.smoothingAlpha
  );
  this.smoothedScale = smoothScalar(
    this.smoothedScale, rawScale, this.smoothingAlpha
  );
  this.smoothedRotation = smoothScalar(
    this.smoothedRotation, rawRotation, this.smoothingAlpha
  );

  const result: FaceTrackingResult = {
    landmarks,
    blendshapes,
    faceCenter: this.smoothedCenter,
    faceScale: this.smoothedScale,
    faceRotation: this.smoothedRotation,
    timestamp
  };

  this.lastResult = result;
  return result;
}
```

### 6.2 HandTracker (`src/mediapipe/HandTracker.ts`)

#### 6.2.1 ç±»ç»“æ„

```typescript
export class HandTracker {
  private handLandmarker: HandLandmarker | null = null;
  private lastResult: HandTrackingResult | null = null;
  private isInitialized = false;

  // æ‰‹éƒ¨ç¨³å®šæ€§è¿½è¸ª
  private handDetectedFrames = 0;
  private minStableFrames = 3;  // æœ€å°‘è¿ç»­æ£€æµ‹å¸§æ•°
}
```

#### 6.2.2 æ£€æµ‹é€»è¾‘

```typescript
detectForVideo(
  video: HTMLVideoElement,
  timestamp: number
): HandTrackingResult {
  if (!this.handLandmarker) {
    return this.getEmptyResult(timestamp);
  }

  const results = this.handLandmarker.detectForVideo(video, timestamp);

  if (!results.landmarks || results.landmarks.length === 0) {
    this.handDetectedFrames = 0;
    return this.getEmptyResult(timestamp);
  }

  // æ›´æ–°ç¨³å®šæ€§è®¡æ•°
  this.handDetectedFrames++;

  const landmarks = results.landmarks[0];
  const worldLandmarks = results.worldLandmarks?.[0] || null;
  const handedness = results.handedness?.[0]?.[0]?.categoryName || null;

  const result: HandTrackingResult = {
    landmarks,
    worldLandmarks,
    handedness: handedness as 'Left' | 'Right' | null,
    timestamp
  };

  this.lastResult = result;
  return result;
}

// åˆ¤æ–­æ‰‹éƒ¨æ˜¯å¦ç¨³å®šæ£€æµ‹
isHandStable(): boolean {
  return this.handDetectedFrames >= this.minStableFrames;
}
```

---

## 7. æ£€æµ‹å™¨å®ç°è¯¦è§£

### 7.1 TeethGate æ£€æµ‹å™¨ (`src/core/detectors/TeethGate.ts`)

#### 7.1.1 è®¾è®¡æ€è·¯

éœ²ç‰™æ£€æµ‹é€šè¿‡ç›‘æµ‹ MediaPipe Face Landmarker è¾“å‡ºçš„ `jawOpen` Blendshape å€¼æ¥åˆ¤å®šã€‚

**åˆ¤å®šæ¡ä»¶**:
- `jawOpen >= threshold` (é»˜è®¤ 0.4)
- æŒç»­ `requiredStableFrames` å¸§ (é»˜è®¤ 5 å¸§ â‰ˆ 167ms)

#### 7.1.2 å®ç°ä»£ç 

```typescript
export class TeethGate {
  private jawOpenThreshold = 0.4;
  private requiredStableFrames = 5;
  private stableFrameCount = 0;

  detect(faceResult: FaceTrackingResult): TeethGateResult {
    const jawOpenScore = faceResult.blendshapes.get('jawOpen') || 0;
    const mouthOpenScore = faceResult.blendshapes.get('mouthOpen') || 0;

    // åˆ¤å®šæ˜¯å¦è¶…è¿‡é˜ˆå€¼
    const isAboveThreshold = jawOpenScore >= this.jawOpenThreshold;

    if (isAboveThreshold) {
      this.stableFrameCount++;
    } else {
      this.stableFrameCount = 0;
    }

    // ç¨³å®šå¸§æ•°è¾¾æ ‡æ‰åˆ¤å®šä¸ºå¼ å˜´
    const isOpen = this.stableFrameCount >= this.requiredStableFrames;

    // è®¡ç®—ç½®ä¿¡åº¦
    const confidence = Math.min(1, (
      (jawOpenScore / this.jawOpenThreshold) * 0.7 +
      (this.stableFrameCount / this.requiredStableFrames) * 0.3
    ));

    return {
      isOpen,
      jawOpenScore,
      mouthOpenScore,
      confidence
    };
  }

  reset(): void {
    this.stableFrameCount = 0;
  }

  getStability(): number {
    return Math.min(1, this.stableFrameCount / this.requiredStableFrames);
  }
}
```

### 7.2 Fist æ£€æµ‹å™¨ (`src/core/detectors/Fist.ts`)

#### 7.2.1 è®¾è®¡æ€è·¯

æ¡æ‹³æ£€æµ‹é€šè¿‡è®¡ç®—æ¯æ ¹æ‰‹æŒ‡çš„"å·æ›²åº¦"æ¥åˆ¤å®šã€‚

**æ‰‹éƒ¨å…³é”®ç‚¹ç´¢å¼•**:
```
0: æ‰‹è…•
1-4: å¤§æ‹‡æŒ‡ (CMC, MCP, IP, TIP)
5-8: é£ŸæŒ‡ (MCP, PIP, DIP, TIP)
9-12: ä¸­æŒ‡ (MCP, PIP, DIP, TIP)
13-16: æ— åæŒ‡ (MCP, PIP, DIP, TIP)
17-20: å°æŒ‡ (MCP, PIP, DIP, TIP)
```

**å·æ›²åˆ¤å®šç®—æ³•**:
- è®¡ç®—æŒ‡å°–åˆ°æ‰‹æŒ‡æ ¹éƒ¨çš„è·ç¦» `tipToBase`
- è®¡ç®—æ‰‹è…•åˆ°æ‰‹æŒ‡æ ¹éƒ¨çš„è·ç¦» `wristToBase`
- å¦‚æœ `tipToBase < wristToBase * 0.4`ï¼Œåˆ™è¯¥æ‰‹æŒ‡è§†ä¸ºå·æ›²

**åˆ¤å®šæ¡ä»¶**:
- å·æ›²æ‰‹æŒ‡æ•° >= 3 (é»˜è®¤)

#### 7.2.2 å®ç°ä»£ç 

```typescript
export class Fist {
  private curledFingerThreshold = 3;

  // æ‰‹æŒ‡å…³é”®ç‚¹ç´¢å¼•
  private fingerIndices = {
    thumb: [1, 2, 3, 4],
    index: [5, 6, 7, 8],
    middle: [9, 10, 11, 12],
    ring: [13, 14, 15, 16],
    pinky: [17, 18, 19, 20]
  };

  detect(handResult: HandTrackingResult): FistResult {
    if (!handResult.landmarks) {
      return {
        isFist: false,
        curledFingersCount: 0,
        handSpread: 1,
        confidence: 0
      };
    }

    const landmarks = handResult.landmarks;
    const wrist = landmarks[0];

    let curledCount = 0;

    // æ£€æŸ¥æ¯æ ¹æ‰‹æŒ‡
    Object.entries(this.fingerIndices).forEach(([name, indices]) => {
      const base = landmarks[indices[0]]; // MCP
      const tip = landmarks[indices[3]];  // TIP

      const tipToBase = distance(tip, base);
      const wristToBase = distance(wrist, base);

      // å·æ›²åˆ¤å®š
      if (tipToBase < wristToBase * 0.4) {
        curledCount++;
      }
    });

    const isFist = curledCount >= this.curledFingerThreshold;

    // è®¡ç®—æ‰‹æŒ‡å¼ å¼€åº¦ï¼ˆç”¨äºå¯è§†åŒ–ï¼‰
    const handSpread = 1 - (curledCount / 5);

    return {
      isFist,
      curledFingersCount: curledCount,
      handSpread,
      confidence: curledCount / 5
    };
  }
}
```

### 7.3 Shake æ£€æµ‹å™¨ (`src/core/detectors/Shake.ts`)

#### 7.3.1 è®¾è®¡æ€è·¯

æ™ƒåŠ¨æ£€æµ‹é€šè¿‡è¿½è¸ªæ‰‹æŒä¸­å¿ƒçš„è¿åŠ¨é€Ÿåº¦æ¥åˆ¤å®šã€‚

**ç®—æ³•**:
1. è¿½è¸ªæ‰‹æŒä¸­å¿ƒä½ç½®ï¼ˆå…³é”®ç‚¹ 9 = ä¸­æŒ‡æ ¹éƒ¨ï¼‰
2. è®¡ç®—å¸§é—´ä½ç§»ï¼Œé™¤ä»¥å¯¹è§’çº¿é•¿åº¦å½’ä¸€åŒ–
3. ç»´æŠ¤ä¸€ä¸ªæ»‘åŠ¨çª—å£ï¼ˆé»˜è®¤ 500msï¼‰çš„é€Ÿåº¦å†å²
4. è®¡ç®—é«˜é€Ÿå¸§å æ¯”ï¼ˆé€Ÿåº¦ > 0.02 çš„å¸§ï¼‰
5. å¦‚æœé«˜é€Ÿå¸§å æ¯” > 15% ä¸”æŒç»­ 4 å¸§ï¼Œåˆ¤å®šä¸ºæ™ƒåŠ¨

#### 7.3.2 å®ç°ä»£ç 

```typescript
export class Shake {
  private speedThreshold = 0.02;      // å½’ä¸€åŒ–é€Ÿåº¦é˜ˆå€¼
  private highSpeedRatio = 0.15;      // é«˜é€Ÿå¸§å æ¯”é˜ˆå€¼
  private windowMs = 500;             // æ»‘çª—æ—¶é•¿
  private requiredStableFrames = 4;   // ç¨³å®šå¸§æ•°è¦æ±‚

  private speedHistory: { speed: number; timestamp: number }[] = [];
  private lastPosition: Point | null = null;
  private lastTimestamp = 0;
  private stableFrameCount = 0;

  detect(
    handResult: HandTrackingResult,
    canvasWidth: number,
    canvasHeight: number
  ): ShakeResult {
    if (!handResult.landmarks) {
      this.reset();
      return this.getEmptyResult();
    }

    const palm = handResult.landmarks[9]; // ä¸­æŒ‡æ ¹éƒ¨
    const currentPosition = {
      x: palm.x * canvasWidth,
      y: palm.y * canvasHeight
    };

    let currentSpeed = 0;

    if (this.lastPosition && this.lastTimestamp > 0) {
      const deltaTime = handResult.timestamp - this.lastTimestamp;
      const dist = distance(currentPosition, this.lastPosition);

      // å½’ä¸€åŒ–é€Ÿåº¦ï¼ˆé™¤ä»¥å¯¹è§’çº¿é•¿åº¦ï¼‰
      const diagonal = Math.sqrt(canvasWidth ** 2 + canvasHeight ** 2);
      currentSpeed = (dist / diagonal) / (deltaTime / 1000);
    }

    this.lastPosition = currentPosition;
    this.lastTimestamp = handResult.timestamp;

    // æ·»åŠ åˆ°å†å²
    this.speedHistory.push({
      speed: currentSpeed,
      timestamp: handResult.timestamp
    });

    // æ¸…ç†è¿‡æœŸæ•°æ®
    const cutoffTime = handResult.timestamp - this.windowMs;
    this.speedHistory = this.speedHistory.filter(
      item => item.timestamp > cutoffTime
    );

    // è®¡ç®—é«˜é€Ÿå¸§å æ¯”
    const highSpeedFrames = this.speedHistory.filter(
      item => item.speed > this.speedThreshold
    ).length;
    const currentHighSpeedRatio = highSpeedFrames / Math.max(1, this.speedHistory.length);

    // åˆ¤å®šæ™ƒåŠ¨
    const isAboveThreshold = currentHighSpeedRatio > this.highSpeedRatio;

    if (isAboveThreshold) {
      this.stableFrameCount++;
    } else {
      this.stableFrameCount = 0;
    }

    const isShaking = this.stableFrameCount >= this.requiredStableFrames;

    // è®¡ç®—å¹³å‡é€Ÿåº¦
    const avgSpeed = this.speedHistory.reduce((sum, item) => sum + item.speed, 0)
                     / Math.max(1, this.speedHistory.length);

    return {
      isShaking,
      currentSpeed,
      avgSpeed,
      highSpeedRatio: currentHighSpeedRatio,
      confidence: Math.min(1, currentHighSpeedRatio / this.highSpeedRatio)
    };
  }

  reset(): void {
    this.speedHistory = [];
    this.lastPosition = null;
    this.lastTimestamp = 0;
    this.stableFrameCount = 0;
  }
}
```

### 7.4 BrushGesture ç»„åˆæ£€æµ‹å™¨ (`src/core/detectors/BrushGesture.ts`)

#### 7.4.1 è®¾è®¡æ€è·¯

BrushGesture æ˜¯ä¸€ä¸ªçŠ¶æ€æœºå¼çš„ç»„åˆæ£€æµ‹å™¨ï¼Œå®ƒï¼š
1. åè°ƒ TeethGateã€Fistã€Shake ä¸‰ä¸ªå­æ£€æµ‹å™¨
2. ç®¡ç†åˆ·ç‰™æ‰‹åŠ¿çš„çŠ¶æ€æµè½¬
3. å®ç°"éœ²ç‰™é”å®š"æœºåˆ¶ï¼Œé˜²æ­¢ç”¨æˆ·é—­å˜´æ—¶çŠ¶æ€é‡ç½®
4. è¿½è¸ªåˆ·ç‰™æ–¹å‘ï¼ˆå‚ç›´/æ°´å¹³ï¼‰

**çŠ¶æ€æµè½¬**:
```
waiting â†’ teeth_open â†’ fist_ready â†’ brushing â†’ complete
   â†‘         â†“            â†“           â†“          â†“
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              (3ç§’æ— éœ²ç‰™è§£é”åå›åˆ° waiting)
```

**éœ²ç‰™é”å®šæœºåˆ¶**:
- å½“ç”¨æˆ·éœ²ç‰™åï¼Œè¿›å…¥ `teeth_open` çŠ¶æ€
- æ­¤å 3 ç§’å†…ï¼Œå³ä½¿ç”¨æˆ·é—­å˜´ï¼ŒçŠ¶æ€ä¸ä¼šå›é€€
- è¿™å…è®¸ç”¨æˆ·åœ¨åˆ·ç‰™æ—¶è‡ªç„¶é—­åˆå˜´å·´
- 3 ç§’åå¦‚æœä»æœªæ£€æµ‹åˆ°éœ²ç‰™ï¼Œæ‰è§£é”å¹¶å›åˆ° `waiting`

#### 7.4.2 å®ç°ä»£ç 

```typescript
export class BrushGesture {
  private teethGate = new TeethGate();
  private fist = new Fist();
  private shake = new Shake();

  // çŠ¶æ€
  private stage: BrushGestureStage = 'waiting';
  private teethConfirmed = false;
  private teethLockTime = 0;
  private teethLockDuration = 3000;  // 3ç§’é”å®š

  // åˆ·ç‰™æŒç»­æ—¶é—´
  private brushingStartTime = 0;
  private minBrushingDuration = 800;  // è‡³å°‘åˆ· 800ms æ‰ç®—æˆåŠŸ

  // åˆ·ç‰™æ–¹å‘è¿½è¸ª
  private movementHistory: Point[] = [];
  private maxHistoryLength = 15;  // çº¦ 500ms @ 30fps

  // å®Œæˆè®¡æ•°
  private completionCount = 0;

  detect(
    detectionResult: DetectionResult,
    canvasWidth: number,
    canvasHeight: number
  ): BrushGestureResult {
    const { faceResult, handResult } = detectionResult;

    // 1. å­æ£€æµ‹å™¨æ£€æµ‹
    const teethResult = this.teethGate.detect(faceResult);
    const fistResult = this.fist.detect(handResult);
    const shakeResult = this.shake.detect(handResult, canvasWidth, canvasHeight);

    const now = Date.now();

    // 2. éœ²ç‰™é”å®šç®¡ç†
    if (teethResult.isOpen) {
      this.teethConfirmed = true;
      this.teethLockTime = now;
    } else if (this.teethConfirmed) {
      // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é”å®šæ—¶é—´
      if (now - this.teethLockTime > this.teethLockDuration) {
        this.teethConfirmed = false;
      }
    }

    // 3. çŠ¶æ€æµè½¬
    this.updateStage(teethResult, fistResult, shakeResult, now);

    // 4. è¿½è¸ªåˆ·ç‰™æ–¹å‘
    this.updateMovementHistory(handResult);
    const brushingDirection = this.calculateBrushingDirection();

    // 5. è®¡ç®—ç»¼åˆç½®ä¿¡åº¦
    const confidence = this.calculateConfidence(
      teethResult, fistResult, shakeResult
    );

    return {
      isBrushing: this.stage === 'brushing' || this.stage === 'complete',
      teethGate: teethResult,
      fist: fistResult,
      shake: shakeResult,
      brushingDirection,
      confidence,
      stage: this.stage
    };
  }

  private updateStage(
    teethResult: TeethGateResult,
    fistResult: FistResult,
    shakeResult: ShakeResult,
    now: number
  ): void {
    switch (this.stage) {
      case 'waiting':
        if (this.teethConfirmed) {
          this.stage = 'teeth_open';
        }
        break;

      case 'teeth_open':
        if (!this.teethConfirmed) {
          this.stage = 'waiting';
        } else if (fistResult.isFist) {
          this.stage = 'fist_ready';
        }
        break;

      case 'fist_ready':
        if (!this.teethConfirmed) {
          this.stage = 'waiting';
        } else if (!fistResult.isFist) {
          this.stage = 'teeth_open';
        } else if (shakeResult.isShaking) {
          this.stage = 'brushing';
          this.brushingStartTime = now;
        }
        break;

      case 'brushing':
        if (!this.teethConfirmed) {
          this.stage = 'waiting';
          this.brushingStartTime = 0;
        } else if (!fistResult.isFist || !shakeResult.isShaking) {
          this.stage = 'fist_ready';
          this.brushingStartTime = 0;
        } else {
          // æ£€æŸ¥æ˜¯å¦åˆ·å¤Ÿæ—¶é—´
          const brushDuration = now - this.brushingStartTime;
          if (brushDuration >= this.minBrushingDuration) {
            this.stage = 'complete';
            this.completionCount++;
          }
        }
        break;

      case 'complete':
        // complete çŠ¶æ€ç”±å¤–éƒ¨çŠ¶æ€æœºç®¡ç†è½¬æ¢å›å…¶ä»–çŠ¶æ€
        break;
    }
  }

  private updateMovementHistory(handResult: HandTrackingResult): void {
    if (!handResult.landmarks) {
      this.movementHistory = [];
      return;
    }

    const palm = handResult.landmarks[9];
    this.movementHistory.push({ x: palm.x, y: palm.y });

    if (this.movementHistory.length > this.maxHistoryLength) {
      this.movementHistory.shift();
    }
  }

  private calculateBrushingDirection(): 'vertical' | 'horizontal' | 'none' {
    if (this.movementHistory.length < 5) {
      return 'none';
    }

    const first = this.movementHistory[0];
    const last = this.movementHistory[this.movementHistory.length - 1];

    const dx = Math.abs(last.x - first.x);
    const dy = Math.abs(last.y - first.y);

    if (dx > dy * 1.5) {
      return 'horizontal';
    } else if (dy > dx * 1.5) {
      return 'vertical';
    }

    return 'none';
  }

  private calculateConfidence(
    teethResult: TeethGateResult,
    fistResult: FistResult,
    shakeResult: ShakeResult
  ): number {
    // æ ¹æ®é˜¶æ®µåˆ†é…æƒé‡
    const weights = {
      waiting:     { teeth: 0.0, fist: 0.0, shake: 0.0 },
      teeth_open:  { teeth: 0.8, fist: 0.0, shake: 0.0 },
      fist_ready:  { teeth: 0.3, fist: 0.7, shake: 0.0 },
      brushing:    { teeth: 0.2, fist: 0.3, shake: 0.5 },
      complete:    { teeth: 0.2, fist: 0.3, shake: 0.5 }
    };

    const w = weights[this.stage];

    return (
      teethResult.confidence * w.teeth +
      fistResult.confidence * w.fist +
      shakeResult.confidence * w.shake
    );
  }

  reset(): void {
    this.teethGate.reset();
    this.fist.reset();
    this.shake.reset();
    this.stage = 'waiting';
    this.teethConfirmed = false;
    this.teethLockTime = 0;
    this.brushingStartTime = 0;
    this.movementHistory = [];
  }

  getCompletionCount(): number {
    return this.completionCount;
  }

  resetCompletionCount(): void {
    this.completionCount = 0;
  }
}
```

---

## 8. æ¸¸æˆçŠ¶æ€æœº

### 8.1 GameStateMachine (`src/core/game/GameStateMachine.ts`)

#### 8.1.1 çŠ¶æ€å®šä¹‰

```typescript
type GameState = 'init' | 'ready' | 'playing' | 'brushing' | 'success' | 'gameover';
```

**çŠ¶æ€è¯´æ˜**:

| çŠ¶æ€ | æè¿° | è§¦å‘æ¡ä»¶ |
|-----|------|---------|
| `init` | åˆå§‹åŒ– | æ¸¸æˆå¯åŠ¨ |
| `ready` | ç­‰å¾…éœ²ç‰™ | åˆå§‹åŒ–å®Œæˆ |
| `playing` | ç­‰å¾…åˆ·ç‰™ | éœ²ç‰™æ£€æµ‹é€šè¿‡ |
| `brushing` | åˆ·ç‰™ä¸­ | åˆ·ç‰™æ‰‹åŠ¿å¼€å§‹ |
| `success` | å¾—åˆ†æˆåŠŸ | åˆ·ç‰™æŒç»­ 800ms |
| `gameover` | æ¸¸æˆç»“æŸ | æ—¶é—´è€—å°½ |

#### 8.1.2 çŠ¶æ€è½¬æ¢å›¾

```
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                                         â”‚
          â–¼                                         â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”€â”€â”€â”€â”€â”€â–¶â”‚ init â”‚â”€â”€â”€â”€â”€â–¶â”‚ ready â”‚â”€â”€â”€â”€â”€â–¶â”‚ playing  â”‚â”€â”€â”€â”¤
       â””â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”¬â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜   â”‚
                         â”‚               â”‚         â”‚
                         â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”   â”‚
                         â”‚    â”‚    brushing    â”‚   â”‚
                         â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
                         â”‚             â”‚           â”‚
                         â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”   â”‚
                         â”‚    â”‚    success     â”‚â”€â”€â”€â”˜
                         â”‚    â”‚  (500ms æ˜¾ç¤º)   â”‚
                         â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ gameover â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 8.1.3 ç§¯åˆ†ç³»ç»Ÿ

```typescript
interface GameStats {
  score: number;          // å½“å‰ç§¯åˆ†
  brushCount: number;     // æ€»å°è¯•æ¬¡æ•°
  successCount: number;   // æˆåŠŸæ¬¡æ•°
  totalBrushTime: number; // æ€»åˆ·ç‰™æ—¶é•¿ (ms)
  accuracy: number;       // å¹³å‡å‡†ç¡®ç‡ (0-1)
}

// ç§¯åˆ†è®¡ç®—
const basePoints = 10;      // åŸºç¡€åˆ†
const accuracyBonus = 5;    // å‡†ç¡®ç‡åŠ æˆ
const finalPoints = basePoints + Math.round(accuracy * accuracyBonus);
// æœ€é«˜ 15 åˆ†ï¼Œæœ€ä½ 10 åˆ†
```

#### 8.1.4 äº‹ä»¶ç³»ç»Ÿ

```typescript
type GameEventType =
  | 'game_initialized'
  | 'state_changed'
  | 'teeth_open_detected'
  | 'brushing_started'
  | 'brush_success'
  | 'game_over';

// äº‹ä»¶æ•°æ®
interface BrushSuccessEventData {
  points: number;
  brushDuration: number;
  accuracy: number;
  totalScore: number;
}

interface StateChangedEventData {
  from: GameState;
  to: GameState;
}
```

#### 8.1.5 æ ¸å¿ƒå®ç°

```typescript
export class GameStateMachine {
  private state: GameState = 'init';
  private stats: GameStats = {
    score: 0,
    brushCount: 0,
    successCount: 0,
    totalBrushTime: 0,
    accuracy: 0
  };

  private brushGesture = new BrushGesture();
  private eventListeners = new Map<string, Function[]>();

  // æ—¶é—´ç®¡ç†
  private gameDurationMs: number;
  private gameStartTime = 0;
  private lastDetectionTime = 0;
  private successStateEnterTime = 0;  // è¿›å…¥ success çŠ¶æ€çš„æ—¶é—´

  // åˆ·ç‰™è¿½è¸ª
  private brushingStartTime = 0;
  private currentBrushDuration = 0;

  constructor(options: {
    gameDurationMs?: number;
    scorePerBrush?: number;
  } = {}) {
    this.gameDurationMs = options.gameDurationMs || 60000;  // é»˜è®¤ 60 ç§’
  }

  initialize(): void {
    this.state = 'ready';
    this.stats = {
      score: 0,
      brushCount: 0,
      successCount: 0,
      totalBrushTime: 0,
      accuracy: 0
    };
    this.brushGesture.reset();
    this.gameStartTime = Date.now();
    this.emit('game_initialized', {});
  }

  update(
    detectionResult: DetectionResult,
    canvasWidth: number,
    canvasHeight: number
  ): void {
    const now = Date.now();
    this.lastDetectionTime = now;

    // æ£€æŸ¥æ¸¸æˆæ—¶é—´
    if (now - this.gameStartTime >= this.gameDurationMs) {
      this.transitionTo('gameover');
      return;
    }

    // æ‰§è¡Œåˆ·ç‰™æ‰‹åŠ¿æ£€æµ‹
    const brushResult = this.brushGesture.detect(
      detectionResult, canvasWidth, canvasHeight
    );

    // çŠ¶æ€æ›´æ–°é€»è¾‘
    this.updateState(brushResult, now);
  }

  private updateState(brushResult: BrushGestureResult, now: number): void {
    switch (this.state) {
      case 'ready':
        // ç­‰å¾…éœ²ç‰™
        if (brushResult.teethGate.isOpen) {
          this.emit('teeth_open_detected', {});
          this.transitionTo('playing');
        }
        break;

      case 'playing':
        // ç­‰å¾…åˆ·ç‰™æ‰‹åŠ¿
        if (brushResult.stage === 'brushing') {
          this.brushingStartTime = now;
          this.emit('brushing_started', {});
          this.transitionTo('brushing');
        } else if (brushResult.stage === 'complete') {
          // å¿«é€Ÿåˆ·ç‰™ï¼Œç›´æ¥å®Œæˆ
          this.handleBrushComplete(brushResult, 800);
        } else if (brushResult.stage === 'waiting') {
          // éœ²ç‰™é”å®šè§£é™¤
          this.transitionTo('ready');
        }
        break;

      case 'brushing':
        // åˆ·ç‰™è¿›è¡Œä¸­
        this.currentBrushDuration = now - this.brushingStartTime;

        if (brushResult.stage === 'complete') {
          this.handleBrushComplete(brushResult, this.currentBrushDuration);
        } else if (brushResult.stage === 'waiting') {
          // åˆ·ç‰™ä¸­æ–­
          this.transitionTo('ready');
        } else if (brushResult.stage !== 'brushing') {
          // æš‚åœï¼ˆä½†æœªè§£é”ï¼‰
          this.transitionTo('playing');
        }
        break;

      case 'success':
        // æˆåŠŸçŠ¶æ€æŒç»­ 500ms
        const timeSinceSuccess = now - this.successStateEnterTime;
        if (timeSinceSuccess > 500) {
          if (brushResult.stage !== 'waiting') {
            // ç»§ç»­æ¸¸æˆ
            this.transitionTo('playing');
          } else {
            this.transitionTo('ready');
          }
        }
        break;

      case 'gameover':
        // æ¸¸æˆç»“æŸï¼Œä¸å†æ›´æ–°
        break;
    }
  }

  private handleBrushComplete(
    brushResult: BrushGestureResult,
    duration: number
  ): void {
    this.stats.brushCount++;
    this.stats.successCount++;
    this.stats.totalBrushTime += duration;

    // è®¡ç®—ç§¯åˆ†
    const accuracy = brushResult.confidence;
    const basePoints = 10;
    const accuracyBonus = 5;
    const points = basePoints + Math.round(accuracy * accuracyBonus);

    this.stats.score += points;
    this.stats.accuracy = (
      (this.stats.accuracy * (this.stats.successCount - 1) + accuracy) /
      this.stats.successCount
    );

    this.emit('brush_success', {
      points,
      brushDuration: duration,
      accuracy,
      totalScore: this.stats.score
    });

    // é‡ç½®åˆ·ç‰™æ£€æµ‹å™¨ä»¥ä¾¿è¿ç»­å¾—åˆ†
    this.brushGesture.reset();

    this.transitionTo('success');
  }

  private transitionTo(newState: GameState): void {
    if (this.state === newState) return;

    const oldState = this.state;
    this.state = newState;

    if (newState === 'success') {
      this.successStateEnterTime = Date.now();
    }

    this.emit('state_changed', { from: oldState, to: newState });

    if (newState === 'gameover') {
      this.emit('game_over', this.stats);
    }
  }

  addEventListener(event: string, callback: Function): void {
    if (!this.eventListeners.has(event)) {
      this.eventListeners.set(event, []);
    }
    this.eventListeners.get(event)!.push(callback);
  }

  private emit(event: string, data: any): void {
    this.eventListeners.get(event)?.forEach(cb => cb(data));
  }

  getState(): GameState {
    return this.state;
  }

  getStats(): GameStats {
    return { ...this.stats };
  }

  getRemainingTime(): number {
    return Math.max(0, this.gameDurationMs - (Date.now() - this.gameStartTime));
  }

  getProgress(): number {
    return Math.min(100, (this.stats.score / 100) * 100);  // 100 åˆ†ä¸ºæ»¡åˆ†
  }
}
```

---

## 9. æ¸²æŸ“ç³»ç»Ÿ

### 9.1 AvatarRenderer (`src/core/rendering/AvatarRenderer.ts`)

#### 9.1.1 å¤´å¥—å®šä½ç®—æ³•

```
1. è·å–äººè„¸è¾¹ç•Œï¼ˆä»å…³é”®ç‚¹è®¡ç®—ï¼‰
   - å·¦çœ¼: landmark[33]
   - å³çœ¼: landmark[263]
   - é¢å¤´: landmark[10]
   - ä¸‹å·´: landmark[152]
   - å·¦è„¸è¾¹: landmark[234]
   - å³è„¸è¾¹: landmark[454]

2. è®¡ç®—äººè„¸å‚æ•°
   - äººè„¸ä¸­å¿ƒ = (å·¦çœ¼ + å³çœ¼) / 2
   - äººè„¸å®½åº¦ = å·¦è„¸è¾¹åˆ°å³è„¸è¾¹è·ç¦»
   - äººè„¸é«˜åº¦ = é¢å¤´åˆ°ä¸‹å·´è·ç¦»
   - æ—‹è½¬è§’åº¦ = atan2(å³çœ¼.y - å·¦çœ¼.y, å³çœ¼.x - å·¦çœ¼.x)

3. è®¡ç®—å¤´å¥—ç¼©æ”¾
   baseScale = äººè„¸å®½åº¦ Ã— 2.2 / å¤´å¥—å›¾ç‰‡å®½åº¦
   finalScale = baseScale Ã— é…ç½®ç¼©æ”¾ç³»æ•°

4. è®¡ç®—å¤´å¥—ä½ç½®
   - faceHoleOffset: è„¸æ´ç›¸å¯¹äºå›¾ç‰‡ä¸­å¿ƒçš„åç§»ï¼ˆå½’ä¸€åŒ– -0.5 åˆ° 0.5ï¼‰
   - anchorOffset: é¢å¤–çš„é”šç‚¹å¾®è°ƒï¼ˆå½’ä¸€åŒ–ï¼‰

   ç›®æ ‡X = äººè„¸ä¸­å¿ƒX - (faceHoleOffset.x Ã— å¤´å¥—å®½åº¦) + (anchorOffset.x Ã— å¤´å¥—å®½åº¦)
   ç›®æ ‡Y = äººè„¸ä¸­å¿ƒY - (faceHoleOffset.y Ã— å¤´å¥—é«˜åº¦) + (anchorOffset.y Ã— å¤´å¥—é«˜åº¦)

5. Canvas å˜æ¢
   ctx.translate(ç›®æ ‡X, ç›®æ ‡Y)
   ctx.rotate(æ—‹è½¬è§’åº¦)
   ctx.drawImage(å¤´å¥—, -å®½åº¦/2, -é«˜åº¦/2, å®½åº¦, é«˜åº¦)
```

#### 9.1.2 å®ç°ä»£ç 

```typescript
export class AvatarRenderer {
  private avatarImage: HTMLImageElement | null = null;
  private isLoading = false;
  private loadError: string | null = null;

  async loadAvatar(avatarUrl: string): Promise<void> {
    if (this.isLoading) return;

    this.isLoading = true;
    this.loadError = null;

    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = 'anonymous';

      img.onload = () => {
        this.avatarImage = img;
        this.isLoading = false;
        resolve();
      };

      img.onerror = () => {
        this.loadError = `Failed to load avatar: ${avatarUrl}`;
        this.isLoading = false;
        reject(new Error(this.loadError));
      };

      img.src = avatarUrl;
    });
  }

  render(
    ctx: CanvasRenderingContext2D,
    faceResult: FaceTrackingResult,
    avatarConfig: AvatarConfig,
    canvasWidth: number,
    canvasHeight: number
  ): void {
    if (!this.avatarImage || !faceResult.landmarks) {
      return;
    }

    // 1. è·å–äººè„¸è¾¹ç•Œ
    const faceBounds = getFaceBoundsFromLandmarks(
      faceResult.landmarks,
      canvasWidth,
      canvasHeight
    );

    // 2. è®¡ç®—å¤´å¥—ç¼©æ”¾
    const baseScale = (faceBounds.faceWidth * 2.2) / this.avatarImage.width;
    const configScale = avatarConfig.scale || 1.0;
    const scale = baseScale * configScale;

    const avatarWidth = this.avatarImage.width * scale;
    const avatarHeight = this.avatarImage.height * scale;

    // 3. è®¡ç®—åç§»
    const faceHoleOffsetX = (avatarConfig.faceHoleOffset?.x || 0) * avatarWidth;
    const faceHoleOffsetY = (avatarConfig.faceHoleOffset?.y || 0) * avatarHeight;
    const anchorOffsetX = (avatarConfig.anchorOffset?.x || 0) * avatarWidth;
    const anchorOffsetY = (avatarConfig.anchorOffset?.y || 0) * avatarHeight;

    // 4. æœ€ç»ˆä½ç½®
    const targetX = faceBounds.center.x - faceHoleOffsetX + anchorOffsetX;
    const targetY = faceBounds.center.y - faceHoleOffsetY + anchorOffsetY;

    // 5. æ¸²æŸ“
    ctx.save();
    ctx.translate(targetX, targetY);
    ctx.rotate(faceBounds.rotation);
    ctx.drawImage(
      this.avatarImage,
      -avatarWidth / 2,
      -avatarHeight / 2,
      avatarWidth,
      avatarHeight
    );
    ctx.restore();
  }

  isReady(): boolean {
    return this.avatarImage !== null && !this.isLoading;
  }

  dispose(): void {
    this.avatarImage = null;
    this.loadError = null;
  }
}
```

### 9.2 DebugRenderer (`src/core/rendering/DebugRenderer.ts`)

```typescript
export class DebugRenderer {
  static renderFaceCenter(
    ctx: CanvasRenderingContext2D,
    center: Point,
    rotation: number,
    color = '#00FF00'
  ): void {
    ctx.save();

    // ç»˜åˆ¶ä¸­å¿ƒç‚¹
    ctx.beginPath();
    ctx.arc(center.x, center.y, 5, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();

    // ç»˜åˆ¶æ—‹è½¬ç®­å¤´
    ctx.translate(center.x, center.y);
    ctx.rotate(rotation);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(30, 0);
    ctx.lineTo(25, -5);
    ctx.moveTo(30, 0);
    ctx.lineTo(25, 5);
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.restore();
  }

  static renderFPS(
    ctx: CanvasRenderingContext2D,
    fps: number,
    x = 10,
    y = 20
  ): void {
    ctx.font = '14px monospace';
    ctx.fillStyle = '#FFFFFF';
    ctx.fillText(`FPS: ${fps.toFixed(1)}`, x, y);
  }

  static renderStatus(
    ctx: CanvasRenderingContext2D,
    faceDetected: boolean,
    handDetected: boolean,
    x = 10,
    y = 40
  ): void {
    ctx.font = '12px monospace';
    ctx.fillStyle = faceDetected ? '#00FF00' : '#FF0000';
    ctx.fillText(`Face: ${faceDetected ? 'YES' : 'NO'}`, x, y);
    ctx.fillStyle = handDetected ? '#00FF00' : '#FF0000';
    ctx.fillText(`Hand: ${handDetected ? 'YES' : 'NO'}`, x, y + 15);
  }
}
```

---

## 10. React Hooks å±‚

### 10.1 useCamera (`src/hooks/useCamera.ts`)

```typescript
export function useCamera() {
  const videoRef = useRef<HTMLVideoElement>(null);
  const [stream, setStream] = useState<MediaStream | null>(null);
  const [isReady, setIsReady] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const startCamera = useCallback(async () => {
    if (isLoading) return;

    setIsLoading(true);
    setError(null);

    try {
      // è¯·æ±‚æ‘„åƒå¤´æƒé™
      const mediaStream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: 'user',
          width: { ideal: 640 },
          height: { ideal: 480 }
        },
        audio: false
      });

      setStream(mediaStream);

      if (videoRef.current) {
        videoRef.current.srcObject = mediaStream;

        // ç­‰å¾…è§†é¢‘å…ƒæ•°æ®åŠ è½½
        await new Promise<void>((resolve, reject) => {
          const video = videoRef.current!;
          const timeout = setTimeout(() => {
            reject(new Error('Video load timeout'));
          }, 15000);

          const onLoaded = () => {
            clearTimeout(timeout);
            video.removeEventListener('loadedmetadata', onLoaded);
            video.removeEventListener('canplay', onLoaded);
            resolve();
          };

          video.addEventListener('loadedmetadata', onLoaded);
          video.addEventListener('canplay', onLoaded);

          // å¦‚æœå·²ç»åŠ è½½
          if (video.readyState >= 2) {
            onLoaded();
          }
        });

        await videoRef.current.play();
        setIsReady(true);
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to start camera');
    } finally {
      setIsLoading(false);
    }
  }, [isLoading]);

  const stopCamera = useCallback(() => {
    if (stream) {
      stream.getTracks().forEach(track => track.stop());
      setStream(null);
    }

    if (videoRef.current) {
      videoRef.current.srcObject = null;
    }

    setIsReady(false);
  }, [stream]);

  // ç»„ä»¶å¸è½½æ—¶æ¸…ç†
  useEffect(() => {
    return () => {
      stopCamera();
    };
  }, []);

  return {
    videoRef,
    stream,
    isReady,
    isLoading,
    error,
    startCamera,
    stopCamera
  };
}
```

### 10.2 useMediaPipe (`src/hooks/useMediaPipe.ts`)

```typescript
interface UseMediaPipeOptions {
  videoRef: RefObject<HTMLVideoElement>;
  onDetection?: (result: DetectionResult) => void;
  smoothingAlpha?: number;
}

export function useMediaPipe(options: UseMediaPipeOptions) {
  const { videoRef, onDetection, smoothingAlpha = 0.3 } = options;

  const [isInitialized, setIsInitialized] = useState(false);
  const [isInitializing, setIsInitializing] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const faceTrackerRef = useRef<FaceTracker | null>(null);
  const handTrackerRef = useRef<HandTracker | null>(null);
  const animationFrameRef = useRef<number>(0);
  const isDetectingRef = useRef(false);

  const initialize = useCallback(async () => {
    if (isInitializing || isInitialized) return;

    setIsInitializing(true);
    setError(null);

    try {
      // å¹¶è¡Œåˆå§‹åŒ–ä¸¤ä¸ªè¿½è¸ªå™¨
      const faceTracker = new FaceTracker();
      const handTracker = new HandTracker();

      await Promise.all([
        faceTracker.initialize(
          mediaPipeConfig.faceModelPath,
          mediaPipeConfig.wasmPath,
          smoothingAlpha
        ),
        handTracker.initialize(
          mediaPipeConfig.handModelPath,
          mediaPipeConfig.wasmPath
        )
      ]);

      faceTrackerRef.current = faceTracker;
      handTrackerRef.current = handTracker;
      setIsInitialized(true);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to initialize MediaPipe');
    } finally {
      setIsInitializing(false);
    }
  }, [isInitializing, isInitialized, smoothingAlpha]);

  const startDetection = useCallback(() => {
    if (!isInitialized || isDetectingRef.current) return;

    isDetectingRef.current = true;

    const detect = () => {
      if (!isDetectingRef.current) return;

      const video = videoRef.current;
      const faceTracker = faceTrackerRef.current;
      const handTracker = handTrackerRef.current;

      if (video && faceTracker && handTracker && video.readyState >= 2) {
        const timestamp = performance.now();

        const faceResult = faceTracker.detectForVideo(video, timestamp);
        const handResult = handTracker.detectForVideo(video, timestamp);

        onDetection?.({
          faceResult,
          handResult
        });
      }

      animationFrameRef.current = requestAnimationFrame(detect);
    };

    detect();
  }, [isInitialized, videoRef, onDetection]);

  const stopDetection = useCallback(() => {
    isDetectingRef.current = false;
    if (animationFrameRef.current) {
      cancelAnimationFrame(animationFrameRef.current);
    }
  }, []);

  // è‡ªåŠ¨åˆå§‹åŒ–
  useEffect(() => {
    initialize();
  }, []);

  // æ¸…ç†
  useEffect(() => {
    return () => {
      stopDetection();
      faceTrackerRef.current?.dispose();
      handTrackerRef.current?.dispose();
    };
  }, []);

  return {
    isInitialized,
    isInitializing,
    error,
    faceTracker: faceTrackerRef.current,
    handTracker: handTrackerRef.current,
    initialize,
    startDetection,
    stopDetection
  };
}
```

### 10.3 useGameStateMachine (`src/hooks/useGameStateMachine.ts`)

```typescript
interface UseGameStateMachineOptions {
  gameDurationMs?: number;
  scorePerBrush?: number;
  enabled?: boolean;
}

export function useGameStateMachine(options: UseGameStateMachineOptions = {}) {
  const { gameDurationMs = 60000, scorePerBrush = 10, enabled = true } = options;

  const [gameState, setGameState] = useState<GameState>('init');
  const [gameStats, setGameStats] = useState<GameStats>({
    score: 0,
    brushCount: 0,
    successCount: 0,
    totalBrushTime: 0,
    accuracy: 0
  });
  const [remainingTime, setRemainingTime] = useState(gameDurationMs);
  const [progress, setProgress] = useState(0);
  const [lastEvent, setLastEvent] = useState<string | null>(null);

  const stateMachineRef = useRef<GameStateMachine | null>(null);

  // åˆå§‹åŒ–çŠ¶æ€æœº
  useEffect(() => {
    if (!enabled) return;

    const sm = new GameStateMachine({ gameDurationMs, scorePerBrush });

    // ç›‘å¬äº‹ä»¶
    sm.addEventListener('state_changed', (data: any) => {
      setGameState(data.to);
      setLastEvent(`state_changed: ${data.from} â†’ ${data.to}`);
    });

    sm.addEventListener('brush_success', (data: any) => {
      setGameStats(sm.getStats());
      setProgress(sm.getProgress());
      setLastEvent(`brush_success: +${data.points} points`);
    });

    sm.addEventListener('game_over', () => {
      setGameStats(sm.getStats());
      setLastEvent('game_over');
    });

    stateMachineRef.current = sm;

    return () => {
      stateMachineRef.current = null;
    };
  }, [enabled, gameDurationMs, scorePerBrush]);

  // æ›´æ–°å‰©ä½™æ—¶é—´
  useEffect(() => {
    if (!enabled || !stateMachineRef.current) return;

    const interval = setInterval(() => {
      if (stateMachineRef.current) {
        setRemainingTime(stateMachineRef.current.getRemainingTime());
      }
    }, 100);

    return () => clearInterval(interval);
  }, [enabled]);

  const updateGame = useCallback((
    detectionResult: DetectionResult,
    canvasWidth: number,
    canvasHeight: number
  ) => {
    stateMachineRef.current?.update(detectionResult, canvasWidth, canvasHeight);
  }, []);

  const initGame = useCallback(() => {
    stateMachineRef.current?.initialize();
  }, []);

  const resetGame = useCallback(() => {
    stateMachineRef.current?.initialize();
    setRemainingTime(gameDurationMs);
    setProgress(0);
    setLastEvent(null);
  }, [gameDurationMs]);

  return {
    gameState,
    gameStats,
    remainingTime,
    progress,
    lastEvent,
    updateGame,
    initGame,
    resetGame,
    stateMachine: stateMachineRef.current
  };
}
```

---

## 11. React ç»„ä»¶å±‚

### 11.1 GameScreen (`src/components/GameScreen.tsx`)

é¡¶å±‚å®¹å™¨ï¼Œç®¡ç†æ¸¸æˆæµç¨‹ï¼š

```typescript
export function GameScreen() {
  const [gameState, setGameState] = useState<'avatar_select' | 'playing'>('avatar_select');
  const [selectedAvatar, setSelectedAvatar] = useState<AvatarConfig | null>(null);

  const handleAvatarSelect = (avatar: AvatarConfig) => {
    setSelectedAvatar(avatar);
    setGameState('playing');
  };

  const handleGameExit = () => {
    setSelectedAvatar(null);
    setGameState('avatar_select');
  };

  if (gameState === 'avatar_select') {
    return <AvatarSelector onSelect={handleAvatarSelect} />;
  }

  return (
    <GamePlayScreen
      avatar={selectedAvatar!}
      onExit={handleGameExit}
      showDebug={gameConfig.debug.enabled}
    />
  );
}
```

### 11.2 AvatarSelector (`src/components/AvatarSelector.tsx`)

å¤´å¥—é€‰æ‹©ç•Œé¢ï¼š

```typescript
interface AvatarSelectorProps {
  onSelect: (avatar: AvatarConfig) => void;
  disabled?: boolean;
}

export function AvatarSelector({ onSelect, disabled }: AvatarSelectorProps) {
  return (
    <div className="avatar-selector">
      <h2>é€‰æ‹©ä½ çš„å¤´å¥—</h2>
      <div className="avatar-grid">
        {avatarConfigs.map(avatar => (
          <button
            key={avatar.id}
            className="avatar-card"
            onClick={() => onSelect(avatar)}
            disabled={disabled}
          >
            <img src={avatar.imgUrl} alt={avatar.name} />
            <span>{avatar.name}</span>
          </button>
        ))}
      </div>
    </div>
  );
}
```

### 11.3 GamePlayScreen (`src/components/GamePlayScreen.tsx`)

æ¸¸æˆä¸»ç•Œé¢ï¼Œæ•´åˆæ‰€æœ‰åŠŸèƒ½ï¼š

```typescript
interface GamePlayScreenProps {
  avatar: AvatarConfig;
  onExit: () => void;
  showDebug?: boolean;
}

export function GamePlayScreen({ avatar, onExit, showDebug }: GamePlayScreenProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const avatarRendererRef = useRef<AvatarRenderer | null>(null);
  const [fps, setFps] = useState(0);

  // Hooks
  const { videoRef, isReady: cameraReady, startCamera, error: cameraError } = useCamera();

  const { isInitialized, startDetection, stopDetection, error: mediaPipeError } = useMediaPipe({
    videoRef,
    onDetection: handleDetection
  });

  const {
    gameState,
    gameStats,
    remainingTime,
    updateGame,
    initGame
  } = useGameStateMachine();

  // åŠ è½½å¤´å¥—
  useEffect(() => {
    const renderer = new AvatarRenderer();
    renderer.loadAvatar(avatar.imgUrl).catch(console.error);
    avatarRendererRef.current = renderer;

    return () => renderer.dispose();
  }, [avatar]);

  // å¯åŠ¨æ‘„åƒå¤´å’Œæ£€æµ‹
  useEffect(() => {
    startCamera();
  }, []);

  useEffect(() => {
    if (cameraReady && isInitialized) {
      startDetection();
      initGame();
    }
  }, [cameraReady, isInitialized]);

  // æ£€æµ‹å›è°ƒ
  function handleDetection(result: DetectionResult) {
    const canvas = canvasRef.current;
    const video = videoRef.current;

    if (!canvas || !video) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // æ›´æ–°æ¸¸æˆçŠ¶æ€
    updateGame(result, canvas.width, canvas.height);

    // æ¸²æŸ“
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // ç»˜åˆ¶è§†é¢‘å¸§
    ctx.drawImage(video, 0, 0);

    // ç»˜åˆ¶å¤´å¥—
    if (result.faceResult.landmarks && avatarRendererRef.current?.isReady()) {
      avatarRendererRef.current.render(
        ctx,
        result.faceResult,
        avatar,
        canvas.width,
        canvas.height
      );
    }

    // è°ƒè¯•ä¿¡æ¯
    if (showDebug) {
      DebugRenderer.renderFPS(ctx, fps);
      DebugRenderer.renderStatus(
        ctx,
        !!result.faceResult.landmarks,
        !!result.handResult.landmarks
      );
    }
  }

  return (
    <div className="game-play-screen">
      <video ref={videoRef} style={{ display: 'none' }} playsInline muted />
      <canvas ref={canvasRef} width={640} height={480} />

      {/* æ¸¸æˆ UI */}
      <div className="game-ui">
        <div className="score">åˆ†æ•°: {gameStats.score}</div>
        <div className="time">
          å‰©ä½™æ—¶é—´: {Math.ceil(remainingTime / 1000)}s
        </div>
        <div className="state">çŠ¶æ€: {gameState}</div>
      </div>

      <button onClick={onExit}>é€€å‡ºæ¸¸æˆ</button>
    </div>
  );
}
```

---

## 12. æ•°æ®æµä¸äº¤äº’

### 12.1 å®Œæ•´æ•°æ®æµå›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           ç”¨æˆ·äº¤äº’å±‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  AvatarSelector  â”‚â”€â”€â”€â–¶â”‚  GamePlayScreen  â”‚â—€â”€â”€â–¶â”‚    GameScreen    â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           React Hooks å±‚                                    â”‚
â”‚                                   â–¼                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚    useCamera     â”‚â”€â”€â”€â–¶â”‚   useMediaPipe   â”‚â”€â”€â”€â–¶â”‚useGameStateMachineâ”‚    â”‚
â”‚  â”‚                  â”‚    â”‚                  â”‚    â”‚                  â”‚     â”‚
â”‚  â”‚ - startCamera()  â”‚    â”‚ - initialize()   â”‚    â”‚ - updateGame()   â”‚     â”‚
â”‚  â”‚ - stopCamera()   â”‚    â”‚ - startDetection â”‚    â”‚ - initGame()     â”‚     â”‚
â”‚  â”‚ - videoRef       â”‚    â”‚ - onDetection()  â”‚    â”‚ - gameState      â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                        â”‚                        â”‚
            â–¼                        â–¼                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         MediaPipe é›†æˆå±‚                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚      FaceTracker       â”‚    â”‚      HandTracker       â”‚                 â”‚
â”‚  â”‚                        â”‚    â”‚                        â”‚                 â”‚
â”‚  â”‚ - 468 landmarks        â”‚    â”‚ - 21 landmarks         â”‚                 â”‚
â”‚  â”‚ - blendshapes          â”‚    â”‚ - worldLandmarks       â”‚                 â”‚
â”‚  â”‚ - center/scale/rotationâ”‚    â”‚ - handedness           â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚                              â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          æ ¸å¿ƒä¸šåŠ¡é€»è¾‘å±‚                                      â”‚
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                        BrushGesture ç»„åˆæ£€æµ‹å™¨                        â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚  â”‚
â”‚  â”‚  â”‚  TeethGate   â”‚  â”‚     Fist     â”‚  â”‚    Shake     â”‚               â”‚  â”‚
â”‚  â”‚  â”‚ (jawOpen>0.4)â”‚  â”‚ (fingers>=3) â”‚  â”‚ (speed>0.02) â”‚               â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚  â”‚
â”‚  â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚  â”‚
â”‚  â”‚                           â”‚                                          â”‚  â”‚
â”‚  â”‚                           â–¼                                          â”‚  â”‚
â”‚  â”‚              BrushGestureResult                                      â”‚  â”‚
â”‚  â”‚   { stage, isBrushing, teethGate, fist, shake, confidence }         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                              â”‚                                             â”‚
â”‚                              â–¼                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                      GameStateMachine                                â”‚  â”‚
â”‚  â”‚                                                                      â”‚  â”‚
â”‚  â”‚   States: init â†’ ready â†’ playing â†’ brushing â†’ success â†’ gameover    â”‚  â”‚
â”‚  â”‚   Stats:  score, brushCount, successCount, accuracy                 â”‚  â”‚
â”‚  â”‚   Events: brush_success(+10~15åˆ†), game_over                        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                            æ¸²æŸ“å±‚                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚    AvatarRenderer      â”‚    â”‚    DebugRenderer       â”‚                 â”‚
â”‚  â”‚                        â”‚    â”‚                        â”‚                 â”‚
â”‚  â”‚ - å¤´å¥—å®šä½å’Œç¼©æ”¾         â”‚    â”‚ - FPS æ˜¾ç¤º             â”‚                 â”‚
â”‚  â”‚ - è·Ÿéšäººè„¸æ—‹è½¬          â”‚    â”‚ - æ£€æµ‹çŠ¶æ€æ˜¾ç¤º          â”‚                 â”‚
â”‚  â”‚ - faceHoleOffset é…ç½®  â”‚    â”‚ - å…³é”®ç‚¹å¯è§†åŒ–          â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 12.2 äº‹ä»¶æµ

```
ç”¨æˆ·å¼ å˜´
    â†“
TeethGate.detect() â†’ isOpen: true
    â†“
BrushGesture.stage â†’ 'teeth_open'
    â†“
GameStateMachine â†’ emit('teeth_open_detected')
    â†“
UI æ›´æ–°æç¤º: "å¾ˆå¥½ï¼ç°åœ¨æ‹¿èµ·ç‰™åˆ·åˆ·ç‰™ï¼"

ç”¨æˆ·æ¡æ‹³
    â†“
Fist.detect() â†’ isFist: true
    â†“
BrushGesture.stage â†’ 'fist_ready'

ç”¨æˆ·æ™ƒåŠ¨
    â†“
Shake.detect() â†’ isShaking: true
    â†“
BrushGesture.stage â†’ 'brushing'
    â†“
GameStateMachine â†’ emit('brushing_started')
    â†“
UI æ›´æ–°æç¤º: "ç»§ç»­åˆ·ï¼"

æŒç»­ 800ms
    â†“
BrushGesture.stage â†’ 'complete'
    â†“
GameStateMachine â†’ è®¡ç®—ç§¯åˆ† â†’ emit('brush_success', { points: 15 })
    â†“
GameStateMachine.state â†’ 'success' (500ms)
    â†“
UI æ›´æ–°: åˆ†æ•° +15, æ˜¾ç¤º"å¤ªæ£’äº†ï¼"

60 ç§’å
    â†“
GameStateMachine â†’ emit('game_over', stats)
    â†“
UI æ˜¾ç¤º: æ¸¸æˆç»“æŸé¡µé¢ï¼Œå±•ç¤ºæœ€ç»ˆåˆ†æ•°
```

---

## 13. å…³é”®ç®—æ³•ä¸å‚æ•°

### 13.1 å‚æ•°æ€»è¡¨

| æ¨¡å— | å‚æ•° | å€¼ | è¯´æ˜ |
|-----|-----|-----|-----|
| TeethGate | jawOpenThreshold | 0.4 | å¼ å˜´é˜ˆå€¼ï¼ˆå®é™…ä½¿ç”¨ï¼‰ |
| TeethGate | requiredStableFrames | 5 | ç¨³å®šå¸§æ•° (~167ms) |
| Fist | curledFingerThreshold | 3 | æœ€å°‘å·æ›²æ‰‹æŒ‡ |
| Fist | curledRatio | 0.4 | å·æ›²åˆ¤å®šæ¯”ä¾‹ |
| Shake | speedThreshold | 0.02 | å½’ä¸€åŒ–é€Ÿåº¦é˜ˆå€¼ |
| Shake | highSpeedRatio | 0.15 | é«˜é€Ÿå¸§å æ¯”é˜ˆå€¼ |
| Shake | windowMs | 500 | æ»‘çª—æ—¶é•¿ |
| Shake | requiredStableFrames | 4 | ç¨³å®šå¸§æ•° (~133ms) |
| BrushGesture | teethLockDuration | 3000 | éœ²ç‰™é”å®šæ—¶é•¿ (ms) |
| BrushGesture | minBrushingDuration | 800 | æœ€çŸ­åˆ·ç‰™æ—¶é•¿ (ms) |
| BrushGesture | movementHistoryLength | 15 | è¿åŠ¨å†å²é•¿åº¦ (~500ms) |
| GameStateMachine | gameDurationMs | 60000 | æ¸¸æˆæ—¶é•¿ (ms) |
| GameStateMachine | scorePerBrush | 10 | åŸºç¡€ç§¯åˆ† |
| GameStateMachine | accuracyBonus | 5 | å‡†ç¡®ç‡åŠ æˆ |
| GameStateMachine | successDisplayMs | 500 | æˆåŠŸçŠ¶æ€æ˜¾ç¤ºæ—¶é•¿ |
| Rendering | smoothingAlpha | 0.3 | EMA å¹³æ»‘ç³»æ•° |
| Rendering | videoResolution | 640Ã—480 | è§†é¢‘åˆ†è¾¨ç‡ |
| AvatarRenderer | faceWidthMultiplier | 2.2 | å¤´å¥—ç›¸å¯¹äººè„¸å®½åº¦çš„å€æ•° |

### 13.2 å…³é”®ç‚¹ç´¢å¼•å‚è€ƒ

**äººè„¸å…³é”®ç‚¹ (Face Landmarker - 468ç‚¹)**:

| ç´¢å¼• | ä½ç½® | ç”¨é€” |
|-----|-----|-----|
| 33 | å·¦çœ¼å¤–è§’ | äººè„¸ä¸­å¿ƒè®¡ç®— |
| 263 | å³çœ¼å¤–è§’ | äººè„¸ä¸­å¿ƒè®¡ç®— |
| 10 | é¢å¤´ä¸­ç‚¹ | äººè„¸é«˜åº¦è®¡ç®— |
| 152 | ä¸‹å·´å°– | äººè„¸é«˜åº¦è®¡ç®— |
| 234 | å·¦è„¸é¢Šè¾¹ç¼˜ | äººè„¸å®½åº¦è®¡ç®— |
| 454 | å³è„¸é¢Šè¾¹ç¼˜ | äººè„¸å®½åº¦è®¡ç®— |

**æ‰‹éƒ¨å…³é”®ç‚¹ (Hand Landmarker - 21ç‚¹)**:

| ç´¢å¼• | ä½ç½® | ç”¨é€” |
|-----|-----|-----|
| 0 | æ‰‹è…• | åŸºå‡†ç‚¹ |
| 4 | å¤§æ‹‡æŒ‡æŒ‡å°– | æ¡æ‹³åˆ¤å®š |
| 8 | é£ŸæŒ‡æŒ‡å°– | æ¡æ‹³åˆ¤å®š |
| 9 | ä¸­æŒ‡æ ¹éƒ¨ | æ‰‹æŒä¸­å¿ƒï¼ˆé€Ÿåº¦è®¡ç®—ï¼‰ |
| 12 | ä¸­æŒ‡æŒ‡å°– | æ¡æ‹³åˆ¤å®š |
| 16 | æ— åæŒ‡æŒ‡å°– | æ¡æ‹³åˆ¤å®š |
| 20 | å°æŒ‡æŒ‡å°– | æ¡æ‹³åˆ¤å®š |

**é‡è¦ Blendshapes**:

| åç§° | èŒƒå›´ | ç”¨é€” |
|-----|-----|-----|
| jawOpen | 0-1 | å¼ å˜´ç¨‹åº¦ï¼ˆä¸»è¦åˆ¤å®šï¼‰ |
| mouthOpen | 0-1 | å˜´éƒ¨å¼ å¼€ï¼ˆè¾…åŠ©ï¼‰ |
| eyeBlinkLeft | 0-1 | å·¦çœ¼çœ¨çœ¼ |
| eyeBlinkRight | 0-1 | å³çœ¼çœ¨çœ¼ |

---

## 14. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 14.1 å·²å®æ–½ä¼˜åŒ–

| ä¼˜åŒ–é¡¹ | æ–¹æ³• | æ•ˆæœ |
|-------|-----|------|
| è§†é¢‘åˆ†è¾¨ç‡ | é™åˆ¶ä¸º 640Ã—480 | å‡å°‘åƒç´ å¤„ç†é‡ |
| å•äººè„¸/æ‰‹æ£€æµ‹ | numFaces=1, numHands=1 | å‡å°‘æ¨¡å‹æ¨ç†æ—¶é—´ |
| EMA å¹³æ»‘ | alpha=0.3 | å‡å°‘æŠ–åŠ¨ï¼Œæå‡è§†è§‰ä½“éªŒ |
| GPU åŠ é€Ÿ | delegate='GPU' | åˆ©ç”¨ WebGL åŠ é€Ÿæ¨ç† |
| æ¨¡å‹æœ¬åœ°åŒ– | æ¨¡å‹æ–‡ä»¶å­˜å‚¨åœ¨ public/ | é¿å…ç½‘ç»œå»¶è¿Ÿ |

### 14.2 å¯é€‰ä¼˜åŒ–

| ä¼˜åŒ–é¡¹ | æ–¹æ³• | é¢„æœŸæ•ˆæœ |
|-------|-----|---------|
| é™é‡‡æ ·æ¨ç† | æ¯éš” 2-3 å¸§æ¨ç†ä¸€æ¬¡ | é™ä½ CPU/GPU è´Ÿè½½ |
| Worker çº¿ç¨‹ | å°†æ¨ç†ç§»è‡³ Web Worker | é¿å…ä¸»çº¿ç¨‹é˜»å¡ |
| æ¨¡å‹é‡åŒ– | ä½¿ç”¨é‡åŒ–æ¨¡å‹ | å‡å°æ¨¡å‹ä½“ç§¯ï¼ŒåŠ å¿«åŠ è½½ |
| æ‡’åŠ è½½ | æŒ‰éœ€åŠ è½½æ¨¡å‹ | åŠ å¿«é¦–å±æ¸²æŸ“ |
| å¸§è·³è¿‡ | ä½é…è®¾å¤‡è·³å¸§æ¸²æŸ“ | ä¿æŒå“åº”æ€§ |

### 14.3 æ€§èƒ½æŒ‡æ ‡

| æŒ‡æ ‡ | ç›®æ ‡å€¼ | æµ‹è¯•ç¯å¢ƒ |
|-----|-------|---------|
| é¦–æ¬¡åŠ è½½æ—¶é—´ | < 3s | M1 Mac / Chrome |
| æ¨¡å‹åˆå§‹åŒ– | < 2s | M1 Mac / Chrome |
| æ¨ç†å¸§ç‡ | > 25 fps | M1 Mac / Chrome |
| æ¸²æŸ“å¸§ç‡ | 30 fps | M1 Mac / Chrome |
| å†…å­˜å ç”¨ | < 200MB | Chrome DevTools |

---

## 15. é—®é¢˜æ’æŸ¥æŒ‡å—

### 15.1 æ‘„åƒå¤´ç›¸å…³

**é—®é¢˜: æ‘„åƒå¤´æƒé™è¢«æ‹’ç»**
```
é”™è¯¯ä¿¡æ¯: NotAllowedError: Permission denied
è§£å†³æ–¹æ¡ˆ:
1. æ£€æŸ¥æµè§ˆå™¨æƒé™è®¾ç½®
2. ç¡®ä¿ä½¿ç”¨ HTTPS è®¿é—®
3. æ¸…é™¤æµè§ˆå™¨ç¼“å­˜åé‡è¯•
```

**é—®é¢˜: æ‘„åƒå¤´é»‘å±**
```
å¯èƒ½åŸå› :
1. video.srcObject æœªç»‘å®š
2. video.play() æœªè°ƒç”¨
3. Canvas å¤§å°ä¸º 0

æ’æŸ¥æ­¥éª¤:
1. æ‰“å¼€ DevTools â†’ Console æŸ¥çœ‹é”™è¯¯
2. æ£€æŸ¥ video.videoWidth æ˜¯å¦ > 0
3. æ£€æŸ¥ canvas.width/height æ˜¯å¦ > 0
```

### 15.2 MediaPipe ç›¸å…³

**é—®é¢˜: æ¨¡å‹åŠ è½½å¤±è´¥**
```
é”™è¯¯ä¿¡æ¯: Failed to load model from path
è§£å†³æ–¹æ¡ˆ:
1. ç¡®è®¤æ¨¡å‹æ–‡ä»¶å­˜åœ¨: public/models/
2. æ£€æŸ¥æ–‡ä»¶å¤§å°:
   - face_landmarker.task ~3.6MB
   - hand_landmarker.task ~7.6MB
3. æ£€æŸ¥ WASM è·¯å¾„æ˜¯å¦æ­£ç¡®
```

**é—®é¢˜: æ£€æµ‹ä¸åˆ°äººè„¸**
```
å¯èƒ½åŸå› :
1. å…‰çº¿ä¸è¶³
2. äººè„¸è§’åº¦è¿‡å¤§
3. ç½®ä¿¡åº¦é˜ˆå€¼è¿‡é«˜

è§£å†³æ–¹æ¡ˆ:
1. æ”¹å–„å…‰çº¿æ¡ä»¶
2. æ­£å¯¹æ‘„åƒå¤´
3. é™ä½ minFaceDetectionConfidence
```

### 15.3 æ¸¸æˆé€»è¾‘ç›¸å…³

**é—®é¢˜: éœ²ç‰™æ£€æµ‹ä¸çµæ•**
```
è°ƒè¯•æ–¹æ³•:
1. å¯ç”¨è°ƒè¯•é¢æ¿: ?debug.enabled=true
2. è§‚å¯Ÿ jawOpen åˆ†æ•°
3. è°ƒæ•´é˜ˆå€¼: ?teethGate.openThreshold=0.3
```

**é—®é¢˜: åˆ·ç‰™åŠ¨ä½œè¯†åˆ«å¤±è´¥**
```
è°ƒè¯•æ­¥éª¤:
1. ç¡®è®¤æ‰‹éƒ¨æ£€æµ‹æ­£å¸¸ï¼ˆçº¢ç‚¹å¯è§ï¼‰
2. æ£€æŸ¥æ¡æ‹³åˆ¤å®šï¼ˆcurledFingersCount >= 3ï¼‰
3. æ£€æŸ¥æ™ƒåŠ¨é€Ÿåº¦ï¼ˆspeed > 0.02ï¼‰
4. ç¡®è®¤åŠ¨ä½œæŒç»­æ—¶é—´ >= 800ms
```

---

## 16. iOS è¿ç§»æŒ‡å—

### 16.1 æ¶æ„è¿ç§»å»ºè®®

| Web å±‚ | iOS å¯¹åº” | è¯´æ˜ |
|-------|---------|------|
| React ç»„ä»¶ | SwiftUI View | UI æ¡†æ¶ |
| React Hooks | @StateObject/@ObservedObject | çŠ¶æ€ç®¡ç† |
| Canvas 2D | Core Graphics / Metal | 2D æ¸²æŸ“ |
| MediaPipe JS | MediaPipe iOS SDK | ML æ¡†æ¶ |
| requestAnimationFrame | CADisplayLink | åŠ¨ç”»å¾ªç¯ |
| localStorage | UserDefaults | æ•°æ®æŒä¹…åŒ– |

### 16.2 æ ¸å¿ƒæ¨¡å—è¿ç§»

**æ£€æµ‹å™¨è¿ç§»**:
- `TeethGate.ts` â†’ `TeethGateDetector.swift`
- `Fist.ts` â†’ `FistDetector.swift`
- `Shake.ts` â†’ `ShakeDetector.swift`
- `BrushGesture.ts` â†’ `BrushGestureDetector.swift`

**ç®—æ³•ä¿æŒä¸å˜**:
- jawOpen é˜ˆå€¼: 0.4
- å·æ›²æ‰‹æŒ‡é˜ˆå€¼: 3
- é€Ÿåº¦é˜ˆå€¼: 0.02
- åˆ·ç‰™æŒç»­æ—¶é•¿: 800ms

### 16.3 MediaPipe iOS é›†æˆ

```swift
// Podfile
pod 'MediaPipeTasksVision'

// åˆå§‹åŒ–
import MediaPipeTasksVision

let options = FaceLandmarkerOptions()
options.baseOptions.modelAssetPath = "face_landmarker.task"
options.runningMode = .liveStream
options.numFaces = 1
options.outputFaceBlendshapes = true

let faceLandmarker = try FaceLandmarker(options: options)
```

### 16.4 å…³é”®å·®å¼‚

| ç‰¹æ€§ | Web | iOS |
|-----|-----|-----|
| åæ ‡ç³» | å·¦ä¸Šè§’åŸç‚¹ | åŒ |
| å½’ä¸€åŒ– | 0-1 | åŒ |
| å¸§ç‡æ§åˆ¶ | requestAnimationFrame | CADisplayLink |
| è§†é¢‘æ•è· | getUserMedia | AVCaptureSession |
| æ¸²æŸ“ | Canvas 2D | Core Animation |

### 16.5 è¿ç§»æ£€æŸ¥æ¸…å•

- [ ] æ‘„åƒå¤´æƒé™é…ç½® (Info.plist)
- [ ] MediaPipe iOS SDK é›†æˆ
- [ ] æ¨¡å‹æ–‡ä»¶æ‰“åŒ… (.task æ–‡ä»¶)
- [ ] æ£€æµ‹å™¨é€»è¾‘è¿ç§»
- [ ] æ¸¸æˆçŠ¶æ€æœºè¿ç§»
- [ ] å¤´å¥—æ¸²æŸ“è¿ç§»
- [ ] åæ ‡ç³»é€‚é…
- [ ] æ€§èƒ½ä¼˜åŒ–ï¼ˆMetal æ¸²æŸ“ï¼‰

---

## é™„å½• A: ä¾èµ–æ¸…å•

```json
{
  "dependencies": {
    "@mediapipe/tasks-vision": "^0.10.18",
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  },
  "devDependencies": {
    "@types/react": "^18.3.12",
    "@types/react-dom": "^18.3.1",
    "@vitejs/plugin-basic-ssl": "^2.0.0",
    "@vitejs/plugin-react-swc": "^3.5.0",
    "typescript": "~5.6.2",
    "vite": "^6.0.5"
  }
}
```

---

## é™„å½• B: å¿«é€Ÿå¯åŠ¨

```bash
# å®‰è£…ä¾èµ–
npm install

# å¯åŠ¨å¼€å‘æœåŠ¡å™¨ï¼ˆHTTPSï¼‰
npm run dev

# è®¿é—®
https://localhost:5173/

# è°ƒè¯•æ¨¡å¼
https://localhost:5173/?debug.enabled=true
```

---

## é™„å½• C: ç‰ˆæœ¬å†å²

| ç‰ˆæœ¬ | æ—¥æœŸ | æ›´æ–°å†…å®¹ |
|-----|------|---------|
| 1.0 | 2024-12-19 | åˆå§‹ç‰ˆæœ¬ï¼ŒMVP åŠŸèƒ½å®Œæˆ |

---

*æœ¬æ–‡æ¡£ç”± Claude Code è‡ªåŠ¨ç”Ÿæˆï¼ŒåŸºäºé¡¹ç›®å®é™…ä»£ç åˆ†æ*

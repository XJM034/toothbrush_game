<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <script src="auth_guard.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="shared_styles.css">
    <script src="mobile_fixes.js"></script>
    <title>Game - Brushing Master</title>
    <style>
        /* æ¸¸æˆç”»å¸ƒå±‚ - å…¨å±èƒŒæ™¯ */
        #game-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 0;
            pointer-events: none;
        }

        /* åŠ è½½é®ç½© - Kawaii é£æ ¼ */
        #loading-overlay {
            position: fixed;
            inset: 0;
            background-color: var(--bg-light);
            background-image: radial-gradient(rgba(0, 104, 55, 0.08) 1px, transparent 1px);
            background-size: 24px 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 300;
            transition: opacity 0.5s ease-out;
        }

        #loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* åŠ è½½å¡ç‰‡å®¹å™¨ */
        .loading-card {
            background: white;
            border: 4px solid var(--stroke-dark);
            border-radius: 32px;
            box-shadow: 8px 8px 0 rgba(44, 62, 80, 0.15);
            padding: 40px 48px;
            text-align: center;
            width: 280px; /* å›ºå®šå®½åº¦ï¼Œé˜²æ­¢æ–‡å­—å˜åŒ–æ—¶å¡ç‰‡å¤§å°è·³åŠ¨ */
        }

        /* å‰ç¥¥ç‰©åŠ¨ç”» */
        .loading-mascot {
            width: 120px;
            height: 120px;
            margin: 0 auto 24px;
            animation: mascotBounce 1.2s ease-in-out infinite;
        }

        @keyframes mascotBounce {
            0%, 100% {
                transform: translateY(0) scale(1);
            }
            50% {
                transform: translateY(-12px) scale(1.05);
            }
        }

        /* åŠ è½½è¿›åº¦æ¡ */
        .loading-progress-container {
            width: 100%;
            height: 20px;
            background: #E5E7EB;
            border: 3px solid var(--stroke-dark);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 16px;
        }

        .loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-green), var(--secondary-green));
            border-radius: 7px;
            transition: width 0.3s ease;
            position: relative;
        }

        .loading-progress-bar::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 4px;
            right: 4px;
            height: 6px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        /* åŠ è½½ç‚¹åŠ¨ç”» */
        .loading-dots {
            display: inline-flex;
            gap: 6px;
            margin-left: 4px;
        }

        .loading-dots span {
            width: 8px;
            height: 8px;
            background: var(--primary-green);
            border-radius: 50%;
            animation: dotPulse 1.4s ease-in-out infinite;
        }

        .loading-dots span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .loading-dots span:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes dotPulse {
            0%, 80%, 100% {
                transform: scale(0.6);
                opacity: 0.5;
            }
            40% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* æƒé™æç¤º */
        #permission-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 400;
            padding: 24px;
        }

        #permission-overlay.show {
            display: flex;
        }

        /* çŠ¶æ€æç¤ºæ¡ */
        #status-bar {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 16px 32px;
            border-radius: 16px;
            font-size: 18px;
            font-weight: bold;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        #status-bar.show {
            opacity: 1;
        }

        /* å¾—åˆ†åŠ¨ç”» */
        .score-popup {
            position: fixed;
            font-size: 32px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 150;
            animation: scoreFloat 1s ease-out forwards;
            pointer-events: none;
        }

        @keyframes scoreFloat {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }

            100% {
                opacity: 0;
                transform: translateY(-100px) scale(1.5);
            }
        }

        .bacteria {
            animation: bounce 2s infinite;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }
    </style>
</head>

<body class="h-screen flex flex-col relative overflow-hidden safe-area-top">

    <!-- æ¸¸æˆç”»å¸ƒï¼ˆæ‘„åƒå¤´ + å¤´å¥—æ¸²æŸ“ï¼‰ -->
    <canvas id="game-canvas"></canvas>

    <!-- åŠ è½½é®ç½© - Kawaii é£æ ¼ -->
    <div id="loading-overlay">
        <div class="loading-card">
            <!-- å‰ç¥¥ç‰© -->
            <div class="loading-mascot">
                <img src="./owl_mascot.svg" alt="çŒ«å¤´é¹°å‰ç¥¥ç‰©" class="w-full h-full object-contain" style="filter: drop-shadow(4px 4px 0 rgba(44, 62, 80, 0.2));" />
            </div>

            <!-- è¿›åº¦æ¡ -->
            <div class="loading-progress-container">
                <div class="loading-progress-bar" id="loading-progress" style="width: 0%"></div>
            </div>

            <!-- çŠ¶æ€æ–‡å­— -->
            <div class="text-lg font-black text-[var(--stroke-dark)] mb-1">
                <span id="loading-label">å‡†å¤‡ä¸­</span>
                <span class="loading-dots" id="loading-dots">
                    <span></span>
                    <span></span>
                    <span></span>
                </span>
            </div>
            <div class="text-sm font-bold text-gray-400" id="loading-detail">æ­£åœ¨å¯åŠ¨æ‘„åƒå¤´</div>
        </div>
    </div>

    <!-- æƒé™æç¤º -->
    <div id="permission-overlay">
        <div class="text-center">
            <div class="text-6xl mb-6">ğŸ“·</div>
            <h2 class="text-white text-2xl font-bold mb-4">éœ€è¦æ‘„åƒå¤´æƒé™</h2>
            <p class="text-gray-300 mb-6">ä¸ºäº†è¯†åˆ«æ‚¨çš„åˆ·ç‰™åŠ¨ä½œï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨æ‘„åƒå¤´ã€‚</p>
            <button id="retry-permission" class="kawaii-button kawaii-button-primary px-8 py-3 text-lg">
                æˆæƒæ‘„åƒå¤´
            </button>
            <button onclick="location.href='home.html'"
                class="kawaii-button kawaii-button-red px-8 py-3 text-lg mt-4 block w-full">
                è¿”å›ä¸»é¡µ
            </button>
        </div>
    </div>

    <!-- UI Overlays -->
    <div class="absolute inset-x-0 top-12 px-6 flex justify-between items-start pointer-events-none z-10">
        <div class="kawaii-card bg-white p-3 flex items-center gap-3">
            <div class="text-xs font-black">
                <div class="text-xs text-gray-400 uppercase">èƒ½é‡å€¼</div>
                <div class="text-[var(--primary-green)]" id="timer-display">--:--</div>
            </div>
            <div class="w-24 kawaii-progress-bg">
                <div class="kawaii-progress-fill" id="progress-bar" style="width: 100%"></div>
            </div>
        </div>
        <div id="exit-btn"
            class="kawaii-button kawaii-button-red w-12 h-12 rounded-full flex items-center justify-center pointer-events-auto">
            <i class="fas fa-times"></i>
        </div>
    </div>

    <!-- ç§¯åˆ†æ˜¾ç¤º -->
    <div class="absolute top-28 left-6 z-10">
        <div class="kawaii-card bg-white bg-opacity-90 px-4 py-2">
            <div class="text-xs text-gray-400 uppercase">ç§¯åˆ†</div>
            <div class="text-2xl font-black text-[var(--primary-green)]" id="score-display">0</div>
        </div>
    </div>

    <!-- çŠ¶æ€æç¤ºæ¡ -->
    <div id="status-bar">è¯·éœ²å‡ºç‰™é½¿</div>

    <!-- Bacteria Targets (è£…é¥°) -->
    <div class="absolute inset-0 flex items-center justify-center pointer-events-none z-5">
        <div class="grid grid-cols-2 gap-20 opacity-30">
            <div class="bacteria text-green-400 text-6xl drop-shadow-[0_4px_0_#333]">
                <i class="fas fa-virus"></i>
            </div>
            <div class="bacteria text-purple-400 text-7xl drop-shadow-[0_4px_0_#333]" style="animation-delay: 0.5s">
                <i class="fas fa-biohazard"></i>
            </div>
            <div class="bacteria text-yellow-400 text-5xl drop-shadow-[0_4px_0_#333]" style="animation-delay: 0.2s">
                <i class="fas fa-bacteria"></i>
            </div>
            <div class="bacteria text-green-300 text-6xl drop-shadow-[0_4px_0_#333]" style="animation-delay: 0.8s">
                <i class="fas fa-virus-slash"></i>
            </div>
        </div>
    </div>

    <!-- Bottom Action Info -->
    <div class="absolute inset-x-0 bottom-12 px-8 z-10">
        <div class="kawaii-card text-center py-4 bg-white bg-opacity-90">
            <div class="flex items-center justify-center gap-4 mb-2">
                <div
                    class="w-10 h-10 bg-white bg-opacity-20 rounded-full flex items-center justify-center overflow-hidden opacity-30">
                    <img src="owl_mascot.svg" class="w-2/3 h-2/3 object-contain" />
                </div>
                <div class="text-xl font-black text-[var(--primary-green)] uppercase" id="action-text">å‡†å¤‡å¼€å§‹ï¼</div>
                <div
                    class="w-10 h-10 bg-white bg-opacity-20 rounded-full flex items-center justify-center overflow-hidden opacity-30">
                    <img src="owl_mascot.svg" class="w-2/3 h-2/3 object-contain" />
                </div>
            </div>
            <p class="text-xs font-black uppercase text-gray-400" id="action-hint">éœ²å‡ºç‰™é½¿ â†’ æ¡æ‹³ â†’ åˆ·åŠ¨</p>
        </div>
    </div>

    <!-- é€€å‡ºç¡®è®¤å¼¹æ¡† -->
    <div id="exit-modal"
        class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-[200] p-6">
        <div class="bg-white rounded-[32px] border-4 border-[#333] w-full max-w-sm shadow-[8px_8px_0_#333] overflow-hidden transform transition-all duration-300 scale-95 opacity-0"
            id="exit-modal-content">
            <div class="p-6">
                <!-- è­¦å‘Šå›¾æ ‡ -->
                <div class="text-center mb-4">
                    <div
                        class="w-16 h-16 mx-auto bg-red-100 rounded-full border-4 border-[#333] flex items-center justify-center">
                        <i class="fas fa-exclamation-triangle text-red-500 text-2xl"></i>
                    </div>
                </div>

                <!-- æç¤ºæ–‡å­— -->
                <h2 class="text-xl font-black text-center mb-2">ç¡®å®šè¦é€€å‡ºå—ï¼Ÿ</h2>
                <p class="text-center text-gray-500 text-sm mb-6">æœ¬æ¬¡åˆ·ç‰™è¿›åº¦å°†ä¸ä¼šä¿å­˜</p>

                <!-- æŒ‰é’® -->
                <div class="flex gap-4">
                    <button class="flex-1 kawaii-button kawaii-button-primary py-3 text-sm font-black"
                        onclick="closeExitModal()">ç»§ç»­åˆ·ç‰™</button>
                    <button class="flex-1 kawaii-button kawaii-button-red py-3 text-sm font-black"
                        onclick="confirmExit()">é€€å‡º</button>
                </div>
            </div>
        </div>
    </div>

    <!-- åŠ è½½ BrushGame å¼•æ“ -->
    <script src="lib/embed/brushing-engine.umd.js"></script>

    <script>
        // ===== æ¸¸æˆé…ç½® =====
        const selectedDuration = parseInt(localStorage.getItem('selectedDuration')) || 2;
        const gameDurationMs = selectedDuration * 60 * 1000;

        // è¯»å–çš®è‚¤é…ç½®
        function getSelectedSkin() {
            return sessionStorage.getItem('selectedSkin') ||
                localStorage.getItem('selectedSkin') ||
                'owl';
        }

        // ===== DOM å…ƒç´  =====
        const canvas = document.getElementById('game-canvas');
        const timerDisplay = document.getElementById('timer-display');
        const progressBar = document.getElementById('progress-bar');
        const scoreDisplay = document.getElementById('score-display');
        const statusBar = document.getElementById('status-bar');
        const actionText = document.getElementById('action-text');
        const actionHint = document.getElementById('action-hint');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingLabel = document.getElementById('loading-label');
        const loadingDetail = document.getElementById('loading-detail');
        const permissionOverlay = document.getElementById('permission-overlay');
        const exitBtn = document.getElementById('exit-btn');

        // ===== æ¸¸æˆçŠ¶æ€ =====
        let gameHandle = null;
        let germsKilled = 0;
        let timerIntervalId = null; // Track interval for cleanup
        let isGameStarting = false; // Re-entry protection flag

        // ===== UI æ›´æ–°å‡½æ•° =====
        function formatTime(ms) {
            const totalSeconds = Math.ceil(ms / 1000);
            const mins = Math.floor(totalSeconds / 60);
            const secs = totalSeconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function updateTimer() {
            if (!gameHandle) return;
            const remaining = gameHandle.getRemainingTime();
            // Clamp remaining to valid range to prevent progress bar overflow/underflow
            const clampedRemaining = Math.max(0, Math.min(remaining, gameDurationMs));
            timerDisplay.textContent = formatTime(clampedRemaining);

            const progress = (clampedRemaining / gameDurationMs) * 100;
            progressBar.style.width = `${Math.max(0, Math.min(100, progress))}%`;
        }

        function showStatus(text, duration = 1500) {
            statusBar.textContent = text;
            statusBar.classList.add('show');
            setTimeout(() => {
                statusBar.classList.remove('show');
            }, duration);
        }

        function showScorePopup(points) {
            const popup = document.createElement('div');
            popup.className = 'score-popup';
            popup.textContent = `+${points}`;
            popup.style.left = `${Math.random() * 60 + 20}%`;
            popup.style.top = `${Math.random() * 30 + 30}%`;
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 1000);
        }

        function updateGameState(state) {
            const stateMessages = {
                'init': { text: 'å‡†å¤‡å¼€å§‹', hint: 'æ­£åœ¨åˆå§‹åŒ–...' },
                'ready': { text: 'éœ²å‡ºç‰™é½¿ï¼', hint: 'å¼ å¤§å˜´å·´éœ²å‡ºç‰™é½¿' },
                'playing': { text: 'å¼€å§‹åˆ·ç‰™ï¼', hint: 'æ¡æ‹³å¹¶å·¦å³åˆ·åŠ¨' },
                'brushing': { text: 'ç»§ç»­ä¿æŒï¼', hint: 'ä¿æŒåˆ·ç‰™åŠ¨ä½œ' },
                'success': { text: 'å¤ªæ£’äº†ï¼', hint: 'ç»§ç»­åŠ æ²¹ï¼' },
                'gameover': { text: 'æ¸¸æˆç»“æŸ', hint: 'æ­£åœ¨è®¡ç®—ç»“æœ...' }
            };

            const msg = stateMessages[state] || { text: state, hint: '' };
            actionText.textContent = msg.text;
            actionHint.textContent = msg.hint;
        }

        // ===== é€€å‡ºå¼¹æ¡† =====
        function showExitModal() {
            const modal = document.getElementById('exit-modal');
            const content = document.getElementById('exit-modal-content');
            modal.classList.remove('hidden');
            setTimeout(() => {
                content.classList.remove('scale-95', 'opacity-0');
                content.classList.add('scale-100', 'opacity-100');
            }, 10);
        }

        function closeExitModal() {
            const modal = document.getElementById('exit-modal');
            const content = document.getElementById('exit-modal-content');
            content.classList.remove('scale-100', 'opacity-100');
            content.classList.add('scale-95', 'opacity-0');
            setTimeout(() => {
                modal.classList.add('hidden');
            }, 300);
        }

        function confirmExit() {
            if (gameHandle) {
                gameHandle.stop();
            }
            location.href = 'home.html';
        }

        exitBtn.onclick = showExitModal;

        // ===== è¿ç»­å¤©æ•° =====
        function getStreakDays() {
            const streak = localStorage.getItem('streakDays');
            return streak ? parseInt(streak) : 1;
        }

        function updateStreak() {
            const lastBrushDate = localStorage.getItem('lastBrushDate');
            const today = new Date().toISOString().split('T')[0];

            if (lastBrushDate === today) {
                return getStreakDays();
            }

            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            const yesterdayStr = yesterday.toISOString().split('T')[0];

            let streak = 1;
            if (lastBrushDate === yesterdayStr) {
                streak = getStreakDays() + 1;
            }

            localStorage.setItem('streakDays', streak.toString());
            localStorage.setItem('lastBrushDate', today);
            return streak;
        }

        // ===== æ¸¸æˆç»“æŸå¤„ç† =====
        // capturedPhotos and remainingTime are passed in since gameHandle may be null after cleanup
        function handleGameOver(stats, capturedPhotos, remainingTime) {
            const streakDays = updateStreak();

            console.log('[Game] æŠ“æ‹ç…§ç‰‡æ•°é‡:', capturedPhotos.length);

            // å‡†å¤‡æ¸¸æˆç»“æœæ•°æ®ï¼ˆä¸å«ç…§ç‰‡ï¼Œåˆ†å¼€å­˜å‚¨ä»¥å‡å°‘é…é¢å‹åŠ›ï¼‰
            const gameResult = {
                duration: selectedDuration,
                germsKilled: stats.successCount * 3, // æ¯æ¬¡æˆåŠŸç®—æ¶ˆç­3ä¸ªç»†èŒ
                streakDays: streakDays,
                score: stats.score,
                successCount: stats.successCount,
                totalBrushTime: stats.totalBrushTime,
                accuracy: stats.accuracy,
                durationMs: gameDurationMs - remainingTime,
                photosAvailable: false // Will be updated if photos are saved successfully
            };

            // å°è¯•ä¿å­˜ç…§ç‰‡ï¼ˆå¸¦é™çº§ç­–ç•¥ï¼Œé¿å… QuotaExceededError é˜»æ–­æµç¨‹ï¼‰
            let photosSaved = false;
            const photosToSave = compressPhotosForStorage(capturedPhotos, 6);

            if (photosToSave.length > 0) {
                // ç­–ç•¥1: å°è¯•ä¿å­˜å…¨éƒ¨ 6 å¼ 
                const fullJson = JSON.stringify(photosToSave);
                photosSaved = safeStorageSet('capturedPhotos', fullJson);

                // ç­–ç•¥2: å¤±è´¥åˆ™å°è¯•åªä¿å­˜ 3 å¼ 
                if (!photosSaved && photosToSave.length > 3) {
                    console.warn('[Storage] Retrying with fewer photos (3)');
                    const reducedPhotos = compressPhotosForStorage(photosToSave, 3);
                    photosSaved = safeStorageSet('capturedPhotos', JSON.stringify(reducedPhotos));
                }

                // ç­–ç•¥3: å†å¤±è´¥åˆ™åªä¿å­˜ 1 å¼ 
                if (!photosSaved && photosToSave.length > 1) {
                    console.warn('[Storage] Retrying with single photo');
                    photosSaved = safeStorageSet('capturedPhotos', JSON.stringify([photosToSave[0]]));
                }

                // ç­–ç•¥4: å…¨éƒ¨å¤±è´¥ï¼Œæ¸…ç©ºç…§ç‰‡å­˜å‚¨ï¼Œç»§ç»­æµç¨‹
                if (!photosSaved) {
                    console.warn('[Storage] All photo save attempts failed, continuing without photos');
                    try { sessionStorage.removeItem('capturedPhotos'); } catch (e) { /* ignore */ }
                }
            }

            // æ›´æ–°æ¸¸æˆç»“æœä¸­çš„ç…§ç‰‡å¯ç”¨æ€§æ ‡è®°
            gameResult.photosAvailable = photosSaved;

            // ä¿å­˜æ¸¸æˆç»“æœï¼ˆä¸å«å¤§ä½“ç§¯ç…§ç‰‡æ•°æ®ï¼‰
            const resultSaved = safeStorageSet('lastGameResult', JSON.stringify(gameResult));
            if (!resultSaved) {
                console.error('[Storage] Failed to save game result, but continuing to result page');
            }

            // æ— è®ºå­˜å‚¨æ˜¯å¦æˆåŠŸï¼Œéƒ½è·³è½¬åˆ°ç»“æœé¡µï¼ˆå­˜å‚¨å¤±è´¥ä¸é˜»æ–­ç”¨æˆ·æµç¨‹ï¼‰
            setTimeout(() => {
                location.href = 'game_result.html';
            }, 1500);
        }

        // ===== Helper: Normalize error to string =====
        function getErrorMessage(err) {
            if (err instanceof Error) return err.message;
            if (typeof err === 'string') return err;
            if (err && typeof err.message === 'string') return err.message;
            return String(err);
        }

        // ===== Helper: Get error name safely =====
        function getErrorName(err) {
            if (err instanceof Error || err instanceof DOMException) return err.name || '';
            if (err && typeof err.name === 'string') return err.name;
            return '';
        }

        // ===== Helper: Check if error is permission denied (multi-signal) =====
        function isPermissionDenied(err) {
            // 1. Check error name (highest priority, works on iOS Safari even when message is empty)
            const name = getErrorName(err);
            const permissionErrorNames = [
                'NotAllowedError',      // Standard: user denied permission
                'SecurityError',        // Some browsers use this for permission issues
                'PermissionDeniedError' // Legacy/non-standard
            ];
            if (permissionErrorNames.includes(name)) {
                return true;
            }

            // 2. Check if it's a DOMException with permission-related code
            if (err instanceof DOMException) {
                // DOMException.SECURITY_ERR = 18, DOMException.NOT_ALLOWED_ERR doesn't have constant
                if (err.code === 18) return true;
            }

            // 3. Fallback: check message string (for browsers that don't set name correctly)
            const msg = getErrorMessage(err).toLowerCase();
            const permissionKeywords = [
                'permission', 'notallowed', 'not allowed', 'denied',
                'getusermedia', 'user denied', 'access denied'
            ];
            return permissionKeywords.some(kw => msg.includes(kw));
        }

        // ===== Helper: Safe sessionStorage write with fallback =====
        function safeStorageSet(key, value, fallbackValue = null) {
            try {
                sessionStorage.setItem(key, value);
                return true;
            } catch (e) {
                console.warn('[Storage] Failed to save', key, ':', e.message || e);
                // Try with fallback value if provided
                if (fallbackValue !== null) {
                    try {
                        sessionStorage.setItem(key, fallbackValue);
                        return true;
                    } catch (e2) {
                        console.warn('[Storage] Fallback also failed:', e2.message || e2);
                    }
                }
                return false;
            }
        }

        // ===== Helper: Compress photos for storage =====
        // Reduces photo count and quality to fit within storage quota
        function compressPhotosForStorage(photos, maxCount = 6) {
            if (!photos || photos.length === 0) return [];

            // Strategy: keep up to maxCount photos, evenly distributed
            let selected = photos;
            if (photos.length > maxCount) {
                const step = photos.length / maxCount;
                selected = [];
                for (let i = 0; i < maxCount; i++) {
                    selected.push(photos[Math.floor(i * step)]);
                }
            }
            return selected;
        }

        // ===== Helper: Derive base paths relative to current page =====
        function getBasePaths() {
            // Get the directory of the current HTML file
            // e.g., https://example.com/app/prototype/game_play.html â†’ https://example.com/app/prototype/
            const pageUrl = new URL('.', window.location.href).href;
            // basePath: current directory (for SkinSet images in same folder)
            const basePath = pageUrl.replace(/\/$/, '');
            // modelBasePath: go up one level from prototype to get to the root where /models/ is
            // e.g., https://example.com/app/prototype/ â†’ https://example.com/app/
            const modelBasePath = new URL('..', pageUrl).href.replace(/\/$/, '');
            return { basePath, modelBasePath };
        }

        // ===== Cleanup previous game resources =====
        function cleanupGame() {
            if (timerIntervalId) {
                clearInterval(timerIntervalId);
                timerIntervalId = null;
            }
            if (gameHandle) {
                try {
                    gameHandle.stop();
                } catch (e) {
                    console.warn('[Game] Cleanup error:', e);
                }
                gameHandle = null;
            }
        }

        // ===== å¯åŠ¨æ¸¸æˆ =====
        async function startGame() {
            // Re-entry protection: prevent multiple concurrent starts
            if (isGameStarting) {
                console.log('[Game] Already starting, ignoring duplicate call');
                return;
            }

            // Cleanup any previous game instance
            cleanupGame();

            isGameStarting = true;
            const skinId = getSelectedSkin();
            const { basePath, modelBasePath } = getBasePaths();
            console.log('[Game] Paths - basePath:', basePath, 'modelBasePath:', modelBasePath);

            // è®¾ç½®å®šæ—¶å™¨æ›´æ–°
            timerIntervalId = setInterval(() => {
                updateTimer();
            }, 100);

            try {
                gameHandle = await BrushGame.start({
                    canvas: canvas,
                    avatarId: skinId,
                    gameDurationMs: gameDurationMs,
                    basePath: basePath,        // å¤´å¥—å›¾ç‰‡åœ¨ /prototype/SkinSet/
                    modelBasePath: modelBasePath, // æ¨¡å‹åœ¨ /models/
                    debug: false,

                    onProgress: (stage, progress) => {
                        const stageNames = {
                            'camera': 'å¯åŠ¨æ‘„åƒå¤´',
                            'models': 'åŠ è½½è¯†åˆ«æ¨¡å‹',
                            'avatar': 'åŠ è½½å¤´å¥—',
                            'ready': 'å‡†å¤‡å°±ç»ª'
                        };
                        const stageDetails = {
                            'camera': 'æ­£åœ¨è·å–æ‘„åƒå¤´æƒé™',
                            'models': 'æ­£åœ¨åŠ è½½ AI è¯†åˆ«æ¨¡å‹',
                            'avatar': 'æ­£åœ¨å‡†å¤‡å¤´å¥—ç´ æ',
                            'ready': 'å³å°†å¼€å§‹æ¸¸æˆ'
                        };
                        // æ›´æ–°è¿›åº¦æ¡
                        const loadingProgressBar = document.getElementById('loading-progress');
                        if (loadingProgressBar) {
                            loadingProgressBar.style.width = `${Math.round(progress * 100)}%`;
                        }
                        // æ›´æ–°æ–‡å­—ï¼ˆåªæ”¹ label çš„ textContentï¼Œä¸å½±å“ dots åŠ¨ç”»ï¼‰
                        const stageName = stageNames[stage] || stage;
                        loadingLabel.textContent = stageName;
                        loadingDetail.textContent = stageDetails[stage] || `è¿›åº¦: ${Math.round(progress * 100)}%`;
                    },

                    onState: (state, event) => {
                        console.log('[Game] State:', state, event);
                        updateGameState(state);

                        if (state === 'ready') {
                            showStatus('è¯·éœ²å‡ºç‰™é½¿ ğŸ˜');
                        } else if (state === 'playing') {
                            showStatus('å¼€å§‹åˆ·ç‰™ï¼ ğŸ’ª');
                        } else if (state === 'success') {
                            showStatus('å¤ªæ£’äº†ï¼ â­');
                        }
                    },

                    onScore: (stats, points) => {
                        console.log('[Game] Score:', stats, '+', points);
                        scoreDisplay.textContent = stats.score;
                        germsKilled = stats.successCount * 3;
                        showScorePopup(points);
                    },

                    onGameOver: (stats) => {
                        console.log('[Game] Game Over:', stats);
                        // Extract data BEFORE cleanup (since cleanup sets gameHandle to null)
                        const capturedPhotos = gameHandle ? gameHandle.getCapturedPhotos() : [];
                        const remainingTime = gameHandle ? gameHandle.getRemainingTime() : 0;
                        cleanupGame();
                        isGameStarting = false;
                        handleGameOver(stats, capturedPhotos, remainingTime);
                    },

                    onError: (err) => {
                        console.error('[Game] Error:', err);
                        cleanupGame();
                        isGameStarting = false;

                        if (isPermissionDenied(err)) {
                            permissionOverlay.classList.add('show');
                        } else {
                            alert('æ¸¸æˆå‡ºé”™: ' + getErrorMessage(err));
                            location.href = 'home.html';
                        }
                    }
                });

                // éšè—åŠ è½½é®ç½©
                loadingOverlay.classList.add('hidden');
                isGameStarting = false;
                updateTimer();

            } catch (err) {
                console.error('[Game] Failed to start:', err);
                cleanupGame();
                isGameStarting = false;

                if (isPermissionDenied(err)) {
                    loadingOverlay.classList.add('hidden');
                    permissionOverlay.classList.add('show');
                } else {
                    loadingLabel.textContent = 'å¯åŠ¨å¤±è´¥';
                    // éšè— dots åŠ¨ç”»
                    const loadingDots = document.getElementById('loading-dots');
                    if (loadingDots) {
                        loadingDots.style.display = 'none';
                    }
                    loadingDetail.textContent = getErrorMessage(err);
                    // è¿›åº¦æ¡æ˜¾ç¤ºçº¢è‰²è¡¨ç¤ºé”™è¯¯
                    const loadingProgressBar = document.getElementById('loading-progress');
                    if (loadingProgressBar) {
                        loadingProgressBar.style.background = 'var(--accent-red)';
                        loadingProgressBar.style.width = '100%';
                    }
                }
            }
        }

        // ===== æƒé™é‡è¯• =====
        document.getElementById('retry-permission').onclick = async () => {
            permissionOverlay.classList.remove('show');
            loadingOverlay.classList.remove('hidden');
            startGame();
        };

        // ===== é¡µé¢åŠ è½½æ—¶å¯åŠ¨æ¸¸æˆ =====
        // éœ€è¦ç”¨æˆ·æ‰‹åŠ¿æ‰èƒ½å¯åŠ¨æ‘„åƒå¤´ï¼ˆiOS è¦æ±‚ï¼‰
        // å¦‚æœæ˜¯ä»å…¶ä»–é¡µé¢ç‚¹å‡»è¿›å…¥çš„ï¼Œå·²ç»æœ‰æ‰‹åŠ¿ä¸Šä¸‹æ–‡
        document.addEventListener('DOMContentLoaded', () => {
            // ç«‹å³æ˜¾ç¤ºåˆå§‹æ—¶é—´
            timerDisplay.textContent = formatTime(gameDurationMs);

            // ç¨å¾®å»¶è¿Ÿå¯åŠ¨ï¼Œç¡®ä¿é¡µé¢å®Œå…¨åŠ è½½
            setTimeout(startGame, 100);
        });
    </script>

</body>

</html>
